<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>算法可视化：三数之和</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
        .smooth-transition {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 结果进入动画 */
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .result-item-enter {
            animation: slideInUp 0.4s ease-out forwards;
        }

        /* 指针跳动动画 */
        @keyframes bounce-small {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        .pointer-bounce {
            animation: bounce-small 1s infinite;
        }

        /* 滚动条美化 */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #6366f1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4f46e5; }
    </style>
</head>
<body class="text-slate-800">
<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- 图标组件 ---
    const Icons = {
        Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
        Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        Step: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>,
        Refresh: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>,
        Random: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>
    };

    // --- 辅助函数 ---
    const parseArray = (str) => {
        return str.split(/[,，\s]+/)
            .map(num => parseInt(num.trim()))
            .filter(n => !isNaN(n));
    };

    // --- 主应用组件 ---
    function App() {
        // --- Config State ---
        const [inputStr, setInputStr] = useState("-1, 0, 1, 2, -1, -4");

        // --- Runtime State ---
        const [nums, setNums] = useState([-4, -1, -1, 0, 1, 2]); // 已排序

        // Pointers
        const [idxI, setIdxI] = useState(0); // 第一个数
        const [idxL, setIdxL] = useState(1); // 左指针
        const [idxR, setIdxR] = useState(5); // 右指针

        // Results
        const [results, setResults] = useState([]);
        const [currentSum, setCurrentSum] = useState(null);

        // Control
        const [isPlaying, setIsPlaying] = useState(false);
        const [isCompleted, setIsCompleted] = useState(false);
        const [message, setMessage] = useState("准备就绪。数据已排序，点击运行开始。");
        const [statusColor, setStatusColor] = useState("text-slate-600");

        // Algorithm Step State: 'check', 'moveL', 'moveR', 'skipI', 'foundSkip'
        const [phase, setPhase] = useState('check');

        const timerRef = useRef(null);

        // --- Initialization ---
        const initAlgorithm = (arrStr) => {
            const arr = parseArray(arrStr).sort((a, b) => a - b);
            setNums(arr);
            setIdxI(0);
            setIdxL(1);
            setIdxR(arr.length - 1);
            setResults([]);
            setCurrentSum(null);
            setPhase('check');
            setIsCompleted(false);
            setIsPlaying(false);
            setMessage("数据已重新排序。初始状态：固定 i=0，L=i+1，R=末尾。");
            setStatusColor("text-slate-600");
            if (timerRef.current) clearInterval(timerRef.current);
        };

        const handleApply = () => initAlgorithm(inputStr);

        const handleRandom = () => {
            const arr = Array.from({length: 8}, () => Math.floor(Math.random() * 20) - 10);
            const str = arr.join(", ");
            setInputStr(str);
            initAlgorithm(str);
        };

        // First Load
        useEffect(() => {
            initAlgorithm(inputStr);
        }, []);

        // --- Step Logic ---
        const step = () => {
            if (isCompleted) return;

            // 边界检查：如果 i 已经遍历完所有可能
            if (idxI >= nums.length - 2) {
                setIsCompleted(true);
                setIsPlaying(false);
                setMessage("遍历结束。已找到所有三元组。");
                setStatusColor("text-green-600");
                return;
            }

            // 核心逻辑
            const valI = nums[idxI];
            const valL = nums[idxL];
            const valR = nums[idxR];
            const sum = valI + valL + valR;

            // 1. 检查阶段：计算和
            if (phase === 'check') {
                setCurrentSum(sum);

                if (valI > 0) {
                    // 优化：如果第一个数大于0，后面不可能凑出0
                    setIsCompleted(true);
                    setIsPlaying(false);
                    setMessage(`当前 nums[i]=${valI} > 0，后续不可能和为0，提前结束。`);
                    setStatusColor("text-slate-500");
                    return;
                }

                if (sum === 0) {
                    setResults(prev => [...prev, [valI, valL, valR]]);
                    setMessage(`找到三元组 [${valI}, ${valL}, ${valR}]！准备跳过重复元素。`);
                    setStatusColor("text-green-600");
                    setPhase('foundSkip');
                } else if (sum < 0) {
                    setMessage(`和为 ${sum} < 0 (太小)，需要更大的数 -> L 右移。`);
                    setStatusColor("text-blue-600");
                    setPhase('moveL');
                } else {
                    setMessage(`和为 ${sum} > 0 (太大)，需要更小的数 -> R 左移。`);
                    setStatusColor("text-pink-600");
                    setPhase('moveR');
                }
            }
            // 2. 移动指针阶段
            else if (phase === 'moveL') {
                if (idxL + 1 < idxR) {
                    setIdxL(prev => prev + 1);
                    setPhase('check');
                } else {
                    // L 和 R 相遇，当前 i 结束，进入下一个 i
                    setPhase('nextI');
                }
            }
            else if (phase === 'moveR') {
                if (idxL < idxR - 1) {
                    setIdxR(prev => prev - 1);
                    setPhase('check');
                } else {
                    // L 和 R 相遇
                    setPhase('nextI');
                }
            }
            // 3. 找到后跳过重复 & 移动双指针
            else if (phase === 'foundSkip') {
                // 简单的处理：先移动，下一步再检查是否重复（为了可视化简单，我们直接移到下一个不重复位置或相遇）
                // 在代码中通常是 while 循环跳过。这里演示一步步跳
                let nextL = idxL + 1;
                let nextR = idxR - 1;

                // 模拟一下 while loop 效果，但为了动画流畅，我们只做一次状态更新
                // 实际可视化中，可以简化为：手动让L和R都缩进

                if (nextL < nextR) {
                    setIdxL(nextL);
                    setIdxR(nextR);
                    // 检查新位置是否重复（可视化省略循环细节，假设用户理解去重逻辑）
                    // 或者可以在这里判断如果 nums[nextL] == nums[idxL] 继续跳，但在 React state 中较难表现 while
                    setMessage("L 和 R 同时向内收缩。");
                    setPhase('check');
                } else {
                    setPhase('nextI');
                }
            }
            // 4. 切换到下一个 i
            else if (phase === 'nextI') {
                let nextI = idxI + 1;
                // 跳过重复的 i
                while (nextI < nums.length - 2 && nums[nextI] === nums[nextI - 1]) {
                    nextI++;
                }

                if (nextI >= nums.length - 2) {
                    setIsCompleted(true);
                    setIsPlaying(false);
                    setMessage("遍历结束。");
                    setStatusColor("text-green-600");
                } else {
                    setIdxI(nextI);
                    setIdxL(nextI + 1);
                    setIdxR(nums.length - 1);
                    setCurrentSum(null);
                    setMessage(`i 移动到索引 ${nextI} (${nums[nextI]})，重置 L 和 R。`);
                    setStatusColor("text-slate-600");
                    setPhase('check');
                }
            }
        };

        // --- Auto Play ---
        useEffect(() => {
            if (isPlaying) {
                timerRef.current = setInterval(step, 1200);
            }
            return () => clearInterval(timerRef.current);
        }, [isPlaying, idxI, idxL, idxR, phase, nums, isCompleted]);

        return (
            <div className="min-h-screen flex flex-col items-center py-8 px-4 sm:px-6">

                {/* 1. Header */}
                <header className="mb-8 text-center space-y-2">
                    <h1 className="text-3xl font-extrabold text-slate-800 tracking-tight">
                        算法可视化：<span className="text-indigo-600">三数之和 (3Sum)</span>
                    </h1>
                    <p className="text-slate-500 text-sm">
                        排序 + 双指针 · 寻找 a + b + c = 0
                    </p>
                </header>

                {/* 2. Config */}
                <div className="w-full max-w-4xl bg-white rounded-xl shadow-lg border border-indigo-100 p-6 mb-8">
                    <div className="flex flex-col sm:flex-row gap-4 items-end">
                        <div className="flex-1 w-full space-y-1">
                            <label className="text-xs font-semibold text-slate-500 uppercase">输入数组 (自动排序)</label>
                            <input
                                type="text"
                                value={inputStr}
                                onChange={(e) => setInputStr(e.target.value)}
                                className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none text-slate-700 font-mono text-sm"
                                placeholder="-1, 0, 1, 2, -1, -4"
                            />
                        </div>
                        <div className="flex gap-2 w-full sm:w-auto">
                            <button onClick={handleApply} className="flex-1 sm:flex-none bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium">应用</button>
                            <button onClick={handleRandom} className="flex-1 sm:flex-none bg-white border border-slate-300 hover:bg-indigo-50 text-slate-700 px-4 py-2 rounded-lg transition-colors text-sm font-medium">随机</button>
                        </div>
                    </div>
                </div>

                {/* 3. Visualization Area */}
                <div className="w-full max-w-4xl mb-8 space-y-6">

                    {/* 数组容器 */}
                    <div className="bg-white rounded-xl shadow-sm border border-indigo-100 p-6 min-h-[140px] relative overflow-hidden">

                        {/* Pointers Label Layer */}
                        <div className="h-8 relative w-full mb-2">
                            {/* Pointer i */}
                            <div className="absolute transition-all duration-500 flex flex-col items-center"
                                 style={{ left: `calc(${idxI} * (3rem + 0.5rem) + 1.5rem)`, transform: 'translateX(-50%)' }}>
                                <span className="text-xs font-bold text-slate-500 mb-1">i</span>
                                <div className="w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-t-[8px] border-t-slate-500"></div>
                            </div>
                            {/* Pointer L */}
                            <div className="absolute transition-all duration-500 flex flex-col items-center z-10"
                                 style={{ left: `calc(${idxL} * (3rem + 0.5rem) + 1.5rem)`, transform: 'translateX(-50%)' }}>
                                <span className="text-xs font-bold text-blue-500 mb-1 pointer-bounce">L</span>
                                <div className="w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-t-[8px] border-t-blue-500"></div>
                            </div>
                            {/* Pointer R */}
                            <div className="absolute transition-all duration-500 flex flex-col items-center z-10"
                                 style={{ left: `calc(${idxR} * (3rem + 0.5rem) + 1.5rem)`, transform: 'translateX(-50%)' }}>
                                <span className="text-xs font-bold text-pink-500 mb-1 pointer-bounce">R</span>
                                <div className="w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-t-[8px] border-t-pink-500"></div>
                            </div>
                        </div>

                        {/* Array Items */}
                        <div className="flex gap-2 justify-start overflow-x-auto pb-4 no-scrollbar">
                            {nums.map((num, idx) => {
                                let bg = "bg-slate-50 border-slate-200 text-slate-400";
                                let scale = "scale-100";

                                if (idx === idxI) { bg = "bg-slate-200 border-slate-400 text-slate-800"; }
                                else if (idx === idxL) { bg = "bg-blue-100 border-blue-500 text-blue-700 font-bold"; scale = "scale-110"; }
                                else if (idx === idxR) { bg = "bg-pink-100 border-pink-500 text-pink-700 font-bold"; scale = "scale-110"; }
                                else if (idx > idxI && idx < idxR) { bg = "bg-white border-slate-300 text-slate-600"; } // unprocessed range

                                return (
                                    <div key={idx} className={`w-12 h-12 flex-shrink-0 flex items-center justify-center rounded-lg border-2 smooth-transition ${bg} ${scale}`}>
                                        {num}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* 计算面板 & 结果列表 */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">

                        {/* Calculation Panel */}
                        <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 flex flex-col items-center justify-center min-h-[160px]">
                            <div className="text-xs font-bold text-slate-400 uppercase tracking-widest mb-4">Current Calculation</div>
                            <div className="flex items-center gap-3 text-xl font-mono text-slate-700">
                                <div className="flex flex-col items-center">
                                    <span className="text-xs text-slate-400 mb-1">nums[i]</span>
                                    <span className="p-2 bg-slate-100 rounded">{nums[idxI]}</span>
                                </div>
                                <span>+</span>
                                <div className="flex flex-col items-center">
                                    <span className="text-xs text-blue-400 mb-1">nums[L]</span>
                                    <span className="p-2 bg-blue-50 text-blue-700 rounded">{nums[idxL]}</span>
                                </div>
                                <span>+</span>
                                <div className="flex flex-col items-center">
                                    <span className="text-xs text-pink-400 mb-1">nums[R]</span>
                                    <span className="p-2 bg-pink-50 text-pink-700 rounded">{nums[idxR]}</span>
                                </div>
                            </div>
                            <div className="mt-4 pt-4 border-t border-slate-100 w-full text-center">
                                <span className="text-slate-400 mr-2">=</span>
                                <span className={`text-2xl font-bold ${
                                    currentSum === 0 ? 'text-green-600' :
                                        currentSum < 0 ? 'text-blue-600' : 'text-pink-600'
                                }`}>
                                        {currentSum !== null ? currentSum : '--'}
                                    </span>
                            </div>
                        </div>

                        {/* Result List */}
                        <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 flex flex-col min-h-[160px]">
                            <div className="flex justify-between items-center mb-4">
                                <span className="text-xs font-bold text-slate-400 uppercase tracking-widest">Found Triplets</span>
                                <span className="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">{results.length}</span>
                            </div>
                            <div className="flex-1 overflow-y-auto max-h-[120px] pr-2 space-y-2 no-scrollbar">
                                {results.length === 0 && (
                                    <div className="text-center text-slate-300 italic text-sm mt-4">暂无结果</div>
                                )}
                                {results.map((res, idx) => (
                                    <div key={idx} className="flex justify-between items-center p-2 bg-green-50 border border-green-200 rounded-lg text-green-800 font-mono text-sm result-item-enter">
                                        <span>[ {res[0]}, {res[1]}, {res[2]} ]</span>
                                        <svg className="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path></svg>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>

                {/* 4. Control Bar */}
                <div className="w-full max-w-2xl bg-white rounded-xl shadow-lg border border-slate-100 overflow-hidden">
                    <div className="flex items-center justify-between p-4 bg-slate-50 border-b border-slate-100">
                        <div className="flex space-x-2">
                            {!isPlaying ? (
                                <button onClick={() => setIsPlaying(true)} disabled={isCompleted} className="flex items-center space-x-1 bg-indigo-600 hover:bg-indigo-700 disabled:bg-indigo-300 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium">
                                    <Icons.Play /> <span>运行</span>
                                </button>
                            ) : (
                                <button onClick={() => setIsPlaying(false)} className="flex items-center space-x-1 bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium">
                                    <Icons.Pause /> <span>暂停</span>
                                </button>
                            )}
                            <button onClick={step} disabled={isPlaying || isCompleted} className="flex items-center space-x-1 bg-white border border-slate-300 hover:bg-slate-50 disabled:opacity-50 text-slate-700 px-4 py-2 rounded-lg transition-colors text-sm font-medium">
                                <Icons.Step /> <span>单步</span>
                            </button>
                        </div>
                        <button onClick={handleApply} className="flex items-center space-x-1 text-slate-500 hover:text-slate-800 transition-colors text-sm">
                            <Icons.Refresh /> <span>重置</span>
                        </button>
                    </div>
                    <div className="p-6 bg-white min-h-[80px] flex items-center justify-center text-center">
                        <p className={`text-lg font-medium transition-colors duration-300 ${statusColor}`}>
                            {message}
                        </p>
                    </div>
                    {isPlaying && (
                        <div className="h-1 w-full bg-slate-100 overflow-hidden">
                            <div className="h-full bg-indigo-500 animate-progress origin-left"></div>
                        </div>
                    )}
                </div>

                <div className="mt-8 text-slate-400 text-xs text-center">
                    <p>3Sum Algorithm Visualization • React + Tailwind</p>
                </div>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

<style>
    @keyframes progress {
        0% { width: 0%; }
        100% { width: 100%; }
    }
    .animate-progress {
        animation: progress 1.2s linear infinite;
    }
</style>
</body>
</html>
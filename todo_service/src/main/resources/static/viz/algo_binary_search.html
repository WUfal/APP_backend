<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>算法可视化：二分查找 vs 线性查找</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Custom Styles for Transitions -->
    <style>
        body {
            background-color: #f8fafc; /* slate-50 */
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
        .smooth-transition {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    // --- 图标组件 (使用 SVG 路径) ---
    const Icons = {
        Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
        Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        Step: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>,
        Refresh: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>,
        Search: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>,
        Random: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>
    };

    // --- 主应用组件 ---
    function App() {
        // --- 状态定义 ---
        // 配置数据
        const [arrayInput, setArrayInput] = useState("1, 3, 5, 7, 9, 11, 13, 15, 17, 19");
        const [targetInput, setTargetInput] = useState("13");
        const [data, setData] = useState([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);
        const [target, setTarget] = useState(13);

        // 模式切换: 'linear' (暴力) | 'binary' (二分)
        const [mode, setMode] = useState('binary');

        // 算法执行状态
        const [isPlaying, setIsPlaying] = useState(false);
        const [isCompleted, setIsCompleted] = useState(false);
        const [message, setMessage] = useState("准备就绪，请点击开始或单步执行。");
        const [statusColor, setStatusColor] = useState("text-slate-600");

        // 线性查找状态
        const [linearIndex, setLinearIndex] = useState(-1);

        // 二分查找状态
        const [low, setLow] = useState(0);
        const [high, setHigh] = useState(9);
        const [mid, setMid] = useState(-1);

        const timerRef = useRef(null);

        // --- 数据处理逻辑 ---

        const handleApplyData = () => {
            resetAlgorithm();
            const arr = arrayInput.split(/[,，\s]+/)
                .map(num => parseInt(num.trim()))
                .filter(n => !isNaN(n));

            // 二分查找必须排序
            arr.sort((a, b) => a - b);

            const uniqueArr = [...new Set(arr)]; // 可选：去重

            setData(uniqueArr);
            setHigh(uniqueArr.length - 1);

            const tgt = parseInt(targetInput);
            if (!isNaN(tgt)) {
                setTarget(tgt);
            }

            // 更新输入框显示排序后的结果
            setArrayInput(uniqueArr.join(", "));
            setMessage("数据已应用并自动排序。准备就绪。");
        };

        const handleRandomData = () => {
            const len = 12;
            const arr = [];
            for (let i = 0; i < len; i++) {
                arr.push(Math.floor(Math.random() * 100));
            }
            arr.sort((a, b) => a - b);
            const uniqueArr = [...new Set(arr)];

            const randomTarget = uniqueArr[Math.floor(Math.random() * uniqueArr.length)]; // 保证能在里面找到
            // 或者 50% 概率找不到: if (Math.random() > 0.5) randomTarget = 999;

            setData(uniqueArr);
            setArrayInput(uniqueArr.join(", "));
            setTarget(randomTarget);
            setTargetInput(randomTarget.toString());
            resetAlgorithm(uniqueArr.length - 1);
            setMessage("随机数据生成完毕。");
        };

        // --- 算法核心逻辑 (单步) ---

        const resetAlgorithm = (currentHigh = null) => {
            setIsPlaying(false);
            setIsCompleted(false);
            setLinearIndex(-1);
            setLow(0);
            setHigh(currentHigh !== null ? currentHigh : data.length - 1);
            setMid(-1);
            setMessage("状态已重置。");
            setStatusColor("text-slate-600");
            if (timerRef.current) clearInterval(timerRef.current);
        };

        const step = () => {
            if (isCompleted) return;

            if (mode === 'linear') {
                // --- 线性查找逻辑 ---
                let nextIndex = linearIndex + 1;

                if (nextIndex >= data.length) {
                    setLinearIndex(nextIndex); // Move past end
                    setIsCompleted(true);
                    setIsPlaying(false);
                    setMessage(`遍历结束，未找到目标值 ${target}。`);
                    setStatusColor("text-red-600");
                    return;
                }

                setLinearIndex(nextIndex);

                if (data[nextIndex] === target) {
                    setIsCompleted(true);
                    setIsPlaying(false);
                    setMessage(`成功！在索引 ${nextIndex} 处找到目标值 ${target}。`);
                    setStatusColor("text-green-600");
                } else if (data[nextIndex] > target) {
                    // 优化：因为数组有序，如果当前值大于目标，后面一定也不存在
                    setIsCompleted(true);
                    setIsPlaying(false);
                    setMessage(`当前值 ${data[nextIndex]} 大于目标 ${target}，且数组有序，停止查找。未找到。`);
                    setStatusColor("text-red-600");
                } else {
                    setMessage(`检查索引 ${nextIndex}：值 ${data[nextIndex]} 不等于 ${target}，继续向后查找。`);
                    setStatusColor("text-blue-600");
                }

            } else {
                // --- 二分查找逻辑 ---

                // 如果 mid 还没计算 (或者上一轮重置了)
                // 逻辑分为两步：1. 计算 mid, 2. 比较并调整
                // 为了演示流畅，我们将 "计算Mid" 和 "比较" 合并在一帧，或者分开。
                // 这里采用：计算新的 mid 并高亮 -> 下一步比较。

                // 实际上二分通常是 while 循环。可视化的本质是把循环拆解。
                // 状态：Low, High 已存在。
                // 检查是否结束
                if (low > high) {
                    setIsCompleted(true);
                    setIsPlaying(false);
                    setMessage(`Low (${low}) > High (${high})，搜索区间为空。未找到目标值 ${target}。`);
                    setStatusColor("text-red-600");
                    return;
                }

                // 如果当前 mid 还没“激活”（-1或上一轮结束），这一步先计算 Mid
                // 但由于 React state 异步，我们直接根据当前的 low/high 计算 mid 并进行判断

                const currentMid = Math.floor((low + high) / 2);
                setMid(currentMid);

                const midValue = data[currentMid];

                if (midValue === target) {
                    setIsCompleted(true);
                    setIsPlaying(false);
                    setMessage(`成功！Middle 索引 ${currentMid} 的值等于目标 ${target}。`);
                    setStatusColor("text-green-600");
                    // 此时 mid 指向正确位置，不需要改 low/high
                } else if (midValue < target) {
                    setMessage(`Middle 值 ${midValue} < 目标 ${target}。目标在右侧区间。Low 调整为 ${currentMid + 1}。`);
                    setStatusColor("text-blue-600");
                    setLow(currentMid + 1);
                } else {
                    setMessage(`Middle 值 ${midValue} > 目标 ${target}。目标在左侧区间。High 调整为 ${currentMid - 1}。`);
                    setStatusColor("text-blue-600");
                    setHigh(currentMid - 1);
                }
            }
        };

        // --- 自动播放控制 ---
        useEffect(() => {
            if (isPlaying) {
                timerRef.current = setInterval(() => {
                    step();
                }, 1000); // 1秒一步
            } else {
                if (timerRef.current) clearInterval(timerRef.current);
            }
            return () => clearInterval(timerRef.current);
        }, [isPlaying, isCompleted, linearIndex, low, high, mid, mode, data]);
        // 依赖项包含 data/index 等是因为 step 函数闭包问题，
        // 实际工程中推荐用 useRef 保存最新 state 或 useReducer，这里为了简化直接依赖并在 step 内部使用最新值逻辑 (React 闭包陷阱注意，这里通过 useEffect 重建 interval 规避)

        // 模式切换时重置
        useEffect(() => {
            resetAlgorithm();
        }, [mode]);

        // --- 渲染辅助 ---

        // 计算格子样式
        const getCellStyle = (index) => {
            let base = "w-10 h-10 sm:w-14 sm:h-14 flex items-center justify-center border-2 rounded-lg text-sm sm:text-lg font-bold smooth-transition relative shadow-sm ";

            if (mode === 'linear') {
                if (index === linearIndex) {
                    return data[index] === target
                        ? base + "bg-green-100 border-green-500 text-green-700 scale-110 shadow-green-200 z-10" // Found
                        : base + "bg-blue-100 border-blue-500 text-blue-700 scale-110 shadow-blue-200 z-10"; // Checking
                }
                if (index < linearIndex) {
                    return base + "bg-slate-100 border-slate-200 text-slate-400 opacity-50"; // Checked
                }
                return base + "bg-white border-slate-300 text-slate-700"; // Pending
            }
            else {
                // Binary Search Styles
                // Found
                if (isCompleted && index === mid && data[index] === target) {
                    return base + "bg-green-100 border-green-500 text-green-700 scale-110 shadow-green-200 z-20";
                }
                // Mid processing
                if (index === mid && !isCompleted) {
                    return base + "bg-yellow-100 border-yellow-500 text-yellow-700 scale-110 z-20";
                }
                // In Range
                if (index >= low && index <= high) {
                    return base + "bg-white border-blue-300 text-slate-800";
                }
                // Out of range (Eliminated)
                return base + "bg-slate-100 border-slate-200 text-slate-300 opacity-40";
            }
        };

        return (
            <div className="min-h-screen flex flex-col items-center py-8 px-4 sm:px-6">

                {/* 1. 标题头 */}
                <header className="mb-8 text-center space-y-2">
                    <h1 className="text-3xl font-extrabold text-slate-800 tracking-tight">
                        算法可视化：<span className="text-blue-600">二分查找</span>
                    </h1>
                    <p className="text-slate-500 text-sm">
                        在 <span className="font-semibold text-slate-700">有序数组</span> 中高效查找目标值的利器
                    </p>
                </header>

                {/* 2. 配置与模式区域 (Card) */}
                <div className="w-full max-w-4xl bg-white rounded-xl shadow-lg border border-slate-100 p-6 mb-8">
                    {/* 模式切换 Tabs */}
                    <div className="flex justify-center mb-6">
                        <div className="bg-slate-100 p-1 rounded-lg flex space-x-1">
                            <button
                                onClick={() => setMode('linear')}
                                className={`px-4 py-2 rounded-md text-sm font-medium transition-all ${mode === 'linear' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                            >
                                解法一：暴力查找 (O(n))
                            </button>
                            <button
                                onClick={() => setMode('binary')}
                                className={`px-4 py-2 rounded-md text-sm font-medium transition-all ${mode === 'binary' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                            >
                                解法二：二分查找 (O(log n))
                            </button>
                        </div>
                    </div>

                    {/* 数据输入 */}
                    <div className="grid grid-cols-1 md:grid-cols-12 gap-4 items-end">
                        <div className="md:col-span-6 space-y-1">
                            <label className="text-xs font-semibold text-slate-500 uppercase">数组数据 (自动排序)</label>
                            <input
                                type="text"
                                value={arrayInput}
                                onChange={(e) => setArrayInput(e.target.value)}
                                className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none text-slate-700 text-sm font-mono"
                                placeholder="输入数字，用逗号分隔"
                            />
                        </div>
                        <div className="md:col-span-2 space-y-1">
                            <label className="text-xs font-semibold text-slate-500 uppercase">查找目标</label>
                            <input
                                type="number"
                                value={targetInput}
                                onChange={(e) => setTargetInput(e.target.value)}
                                className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none text-slate-700 text-sm font-mono"
                            />
                        </div>
                        <div className="md:col-span-4 flex space-x-2">
                            <button
                                onClick={handleApplyData}
                                className="flex-1 flex items-center justify-center space-x-1 bg-slate-800 hover:bg-slate-900 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                            >
                                <Icons.Refresh /> <span>应用</span>
                            </button>
                            <button
                                onClick={handleRandomData}
                                className="flex-1 flex items-center justify-center space-x-1 bg-white border border-slate-300 hover:bg-slate-50 text-slate-700 px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                            >
                                <Icons.Random /> <span>随机</span>
                            </button>
                        </div>
                    </div>
                </div>

                {/* 3. 核心可视化区域 */}
                <div className="w-full max-w-4xl mb-8 relative">
                    {/* 指针指示层 (Height placeholder + Absolute elements) */}
                    <div className="h-12 w-full relative mb-2 select-none">
                        {mode === 'binary' && data.map((_, idx) => (
                            <div key={idx}
                                 className="absolute top-0 transition-all duration-500"
                                 style={{
                                     left: `calc(${idx} * (var(--cell-size) + var(--gap)) + var(--cell-size)/2)`,
                                     transform: 'translateX(-50%)',
                                     // 响应式计算在 CSS 中较难，这里用 inline style 配合 JS 计算或者简单布局
                                     // 为了简化，我们让指示器跟随 array items 的 flex 布局
                                 }}
                            >
                            </div>
                        ))}
                        {/* 由于 Flex 布局，绝对定位比较难对齐，我们直接在 Array Item 内部或上方渲染 Pointer */}
                    </div>

                    {/* 数组容器 */}
                    <div className="flex flex-wrap justify-center gap-2 sm:gap-4 p-4 min-h-[120px]">
                        {data.map((num, idx) => (
                            <div key={idx} className="flex flex-col items-center group">
                                {/* 顶部指针 (Linear) */}
                                <div className={`h-6 mb-1 text-xs font-bold transition-opacity duration-300 ${mode === 'linear' && idx === linearIndex ? 'opacity-100 text-blue-600' : 'opacity-0'}`}>
                                    ↓ Idx
                                </div>

                                {/* 顶部指针 (Binary) */}
                                <div className="h-6 mb-1 relative w-full flex justify-center">
                                    {mode === 'binary' && idx === low && (
                                        <span className="absolute text-xs font-bold text-blue-500 -top-1 animate-bounce">L</span>
                                    )}
                                    {mode === 'binary' && idx === high && (
                                        <span className="absolute text-xs font-bold text-purple-500 -top-1 animate-bounce" style={{animationDelay: '0.1s'}}>R</span>
                                    )}
                                    {mode === 'binary' && idx === mid && (
                                        <span className="absolute text-xs font-bold text-yellow-600 top-4">M</span>
                                    )}
                                </div>

                                {/* 数组单元格 */}
                                <div className={getCellStyle(idx)}>
                                    {num}
                                    {/* 索引标记 */}
                                    <span className="absolute -bottom-6 text-[10px] text-slate-400 font-normal">
                                            {idx}
                                        </span>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>

                {/* 4. 控制栏与状态栏 */}
                <div className="w-full max-w-2xl bg-white rounded-xl shadow-lg border border-slate-100 overflow-hidden">

                    {/* 按钮组 */}
                    <div className="flex items-center justify-between p-4 bg-slate-50 border-b border-slate-100">
                        <div className="flex space-x-2">
                            {!isPlaying ? (
                                <button
                                    onClick={() => setIsPlaying(true)}
                                    disabled={isCompleted}
                                    className="flex items-center space-x-1 bg-blue-600 hover:bg-blue-700 disabled:bg-blue-300 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                                >
                                    <Icons.Play /> <span>自动播放</span>
                                </button>
                            ) : (
                                <button
                                    onClick={() => setIsPlaying(false)}
                                    className="flex items-center space-x-1 bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                                >
                                    <Icons.Pause /> <span>暂停</span>
                                </button>
                            )}

                            <button
                                onClick={step}
                                disabled={isPlaying || isCompleted}
                                className="flex items-center space-x-1 bg-white border border-slate-300 hover:bg-slate-50 disabled:opacity-50 text-slate-700 px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                            >
                                <Icons.Step /> <span>单步执行</span>
                            </button>
                        </div>

                        <button
                            onClick={() => resetAlgorithm()}
                            className="flex items-center space-x-1 text-slate-500 hover:text-slate-800 transition-colors text-sm"
                        >
                            <Icons.Refresh /> <span>重置状态</span>
                        </button>
                    </div>

                    {/* 状态解释文本区域 */}
                    <div className="p-6 bg-white min-h-[100px] flex items-center justify-center text-center">
                        <p className={`text-lg font-medium transition-colors duration-300 ${statusColor}`}>
                            {message}
                        </p>
                    </div>

                    {/* 进度条 (装饰用) */}
                    {isPlaying && (
                        <div className="h-1 w-full bg-slate-100 overflow-hidden">
                            <div className="h-full bg-blue-500 animate-progress origin-left"></div>
                        </div>
                    )}
                </div>

                {/* 底部信息 */}
                <div className="mt-8 text-slate-400 text-xs">
                    <p>Binary Search Algorithm Visualization • React + Tailwind</p>
                </div>

            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

<style>
    @keyframes progress {
        0% { width: 0%; }
        100% { width: 100%; }
    }
    .animate-progress {
        animation: progress 1s linear infinite;
    }
</style>
</body>
</html>
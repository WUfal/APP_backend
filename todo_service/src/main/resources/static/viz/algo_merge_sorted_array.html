<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>合并两个有序数组 - 算法可视化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { background-color: #f8fafc; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .cell-transition { transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .pointer-transition { transition: left 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .fade-enter { animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        /* 移动动画：当数字从 nums1/nums2 飞到目标位置时 */
        @keyframes moveUp {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px) scale(1.1); }
            100% { transform: translateY(0); }
        }
        .moving { animation: moveUp 0.4s ease-in-out; }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- 图标组件 ---
    const Icons = {
        Play: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
        Pause: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        Step: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>,
        Reset: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /></svg>,
        Settings: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>,
        Shuffle: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>
    };

    // --- 辅助函数 ---
    const parseInput = (str) => {
        return str.split(/[,，\s]+/)
            .map(v => parseInt(v.trim()))
            .filter(v => !isNaN(v))
            .sort((a, b) => a - b);
    };

    const App = () => {
        // --- 状态定义 ---
        const [input1, setInput1] = useState("1, 2, 3");
        const [input2, setInput2] = useState("2, 5, 6");

        // 核心数据
        // 使用 null 代表空位，而不是 0
        const [nums1, setNums1] = useState([1, 2, 3, null, null, null]);
        const [m, setM] = useState(3);
        const [nums2, setNums2] = useState([2, 5, 6]);
        const [n, setN] = useState(3);

        // 指针
        const [p1, setP1] = useState(2);
        const [p2, setP2] = useState(2);
        const [p, setP] = useState(5);

        // 运行控制
        const [isPlaying, setIsPlaying] = useState(false);
        const [isFinished, setIsFinished] = useState(false);
        const [message, setMessage] = useState("准备就绪");
        const [activeIdx, setActiveIdx] = useState(-1);

        const timerRef = useRef(null);

        // --- 初始化 ---
        const reset = (arr1Str = input1, arr2Str = input2) => {
            const arr1 = parseInput(arr1Str);
            const arr2 = parseInput(arr2Str);
            const len1 = arr1.length;
            const len2 = arr2.length;

            // 构建带 buffer 的 nums1, 使用 null 填充 buffer
            const fullNums1 = [...arr1, ...new Array(len2).fill(null)];

            setNums1(fullNums1);
            setNums2(arr2);
            setM(len1);
            setN(len2);
            setP1(len1 - 1);
            setP2(len2 - 1);
            setP(len1 + len2 - 1);

            setActiveIdx(-1);
            setIsPlaying(false);
            setIsFinished(false);
            setMessage("状态已重置。准备从后向前合并。");
            if (timerRef.current) clearInterval(timerRef.current);
        };

        const loadInput = () => reset(input1, input2);

        const randomInput = () => {
            const len1 = 3 + Math.floor(Math.random() * 3);
            const len2 = 3 + Math.floor(Math.random() * 3);
            const arr1 = Array.from({length: len1}, () => Math.floor(Math.random() * 20));
            const arr2 = Array.from({length: len2}, () => Math.floor(Math.random() * 20));

            const str1 = arr1.join(", ");
            const str2 = arr2.join(", ");
            setInput1(str1);
            setInput2(str2);
            reset(str1, str2);
            setMessage("随机数组生成完毕。");
        };

        useEffect(() => {
            reset();
        }, []);

        // --- 核心算法逻辑 ---
        const stepForward = () => {
            if (isFinished) return;

            let nextNums1 = [...nums1];
            let nextP1 = p1;
            let nextP2 = p2;
            let nextP = p;
            let msg = "";

            // 算法结束条件
            if (nextP2 < 0) {
                setIsFinished(true);
                setIsPlaying(false);
                setMessage("nums2 已全部合并，算法结束！");
                return;
            }

            let valToWrite;
            let pickFrom1 = false;

            // 比较逻辑：决定取 nums1 还是 nums2
            if (nextP1 >= 0 && nextP2 >= 0) {
                if (nums1[nextP1] > nums2[nextP2]) pickFrom1 = true;
            } else if (nextP1 >= 0) {
                pickFrom1 = true; // nums2 已空
            } else {
                pickFrom1 = false; // nums1 已空
            }

            if (pickFrom1) {
                valToWrite = nums1[nextP1];
                nextNums1[nextP] = valToWrite;

                // 关键修复：如果只是移动位置（p != p1），将原位置设为 null，避免视觉上的重复
                if (nextP !== nextP1) {
                    nextNums1[nextP1] = null;
                }

                msg = `nums1[${nextP1}] (${valToWrite}) > nums2[${nextP2}] (${nums2[nextP2] || '-'})，取 nums1 元素移动到 nums1[${nextP}]`;
                nextP1--;
            } else {
                valToWrite = nums2[nextP2];
                nextNums1[nextP] = valToWrite;

                if (nextP1 >= 0) {
                    msg = `nums1[${nextP1}] (${nums1[nextP1]}) <= nums2[${nextP2}] (${valToWrite})，取 nums2 元素填入 nums1[${nextP}]`;
                } else {
                    msg = `nums1 已空，取 nums2[${nextP2}] (${valToWrite}) 填入 nums1[${nextP}]`;
                }
                nextP2--;
            }

            setNums1(nextNums1);
            setP1(nextP1);
            setP2(nextP2);
            setP(nextP - 1);
            setActiveIdx(nextP);
            setMessage(msg);
        };

        // --- 自动播放 ---
        useEffect(() => {
            let timer;
            if (isPlaying && !isFinished) {
                timer = setInterval(() => {
                    stepForward();
                }, 1200);
            }
            return () => clearInterval(timer);
        }, [isPlaying, isFinished, p1, p2, p, nums1, nums2]);

        // --- 渲染 ---
        const getCellClass1 = (idx) => {
            let base = "w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center border rounded-lg font-mono text-sm sm:text-lg font-bold relative cell-transition shadow-sm ";

            // 指针 P (Writer)
            if (idx === p && !isFinished) {
                base += "border-violet-500 bg-violet-50 text-violet-800 ring-2 ring-violet-200 z-10 ";
            } else if (idx === activeIdx) {
                // 刚写入的位置
                base += "bg-green-100 border-green-500 text-green-700 moving ";
            } else if (idx <= p1) {
                // p1 之前的有效数据
                base += "bg-blue-50 border-blue-200 text-blue-700 ";
            } else if (idx > p && idx < nums1.length) {
                // 已经填好的尾部数据
                base += "bg-slate-100 border-slate-300 text-slate-500 ";
            } else {
                // Buffer / Empty
                base += "bg-slate-50 border-slate-200 text-slate-300 border-dashed ";
            }

            return base;
        };

        const getCellClass2 = (idx) => {
            let base = "w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center border rounded-lg font-mono text-sm sm:text-lg font-bold relative cell-transition shadow-sm ";

            if (idx <= p2) {
                base += "bg-rose-50 border-rose-200 text-rose-700 ";
            } else {
                // 已处理的数据
                base += "bg-slate-100 border-slate-200 text-slate-300 opacity-50 ";
            }
            return base;
        };

        return (
            <div className="max-w-4xl mx-auto p-4 sm:p-6">
                {/* 1. 顶部配置 */}
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-4 mb-6">
                    <div className="flex items-center gap-2 mb-3 text-slate-700 font-bold">
                        <Icons.Settings />
                        <span>数组配置 (输入有序数组)</span>
                    </div>
                    <div className="flex flex-col gap-3">
                        <div className="flex items-center gap-2">
                            <label className="w-16 text-xs font-bold text-blue-500 uppercase">Nums 1</label>
                            <input
                                type="text"
                                value={input1}
                                onChange={(e) => setInput1(e.target.value)}
                                className="flex-1 border border-slate-300 rounded-lg px-3 py-2 font-mono text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                                placeholder="1, 2, 3"
                            />
                        </div>
                        <div className="flex items-center gap-2">
                            <label className="w-16 text-xs font-bold text-rose-500 uppercase">Nums 2</label>
                            <input
                                type="text"
                                value={input2}
                                onChange={(e) => setInput2(e.target.value)}
                                className="flex-1 border border-slate-300 rounded-lg px-3 py-2 font-mono text-sm focus:outline-none focus:ring-2 focus:ring-rose-500"
                                placeholder="2, 5, 6"
                            />
                        </div>
                        <div className="flex gap-2 justify-end mt-1">
                            <button onClick={loadInput} className="px-4 py-2 bg-violet-600 text-white rounded-lg hover:bg-violet-700 transition font-medium text-sm">
                                加载数据
                            </button>
                            <button onClick={randomInput} className="px-3 py-2 bg-slate-100 text-slate-600 rounded-lg hover:bg-slate-200 transition" title="随机生成">
                                <Icons.Shuffle />
                            </button>
                        </div>
                    </div>
                </div>

                {/* 2. 主体区 */}
                <div className="bg-white rounded-xl shadow-lg border border-slate-200 overflow-hidden">
                    {/* Header */}
                    <div className="border-b border-slate-100 bg-slate-50 p-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                        <div>
                            <h1 className="text-xl font-bold text-slate-800">合并两个有序数组</h1>
                            <p className="text-xs text-slate-500 mt-1">逆向双指针法 (Reverse Two Pointers) · O(m+n)</p>
                        </div>
                        <div className="flex gap-4 text-xs font-mono">
                            <div className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-violet-500"></span> P (Write)
                            </div>
                            <div className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-blue-500"></span> P1 (Read)
                            </div>
                            <div className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-rose-500"></span> P2 (Read)
                            </div>
                        </div>
                    </div>

                    {/* Canvas */}
                    <div className="p-6 sm:p-10 bg-slate-50 min-h-[320px] flex flex-col items-center justify-center gap-10">

                        {/* Nums 1 (Target) */}
                        <div className="relative w-full overflow-x-auto flex justify-center pb-8 pt-2">
                            <div className="flex gap-2">
                                {nums1.map((num, idx) => (
                                    <div key={`n1-${idx}`} className="flex flex-col items-center relative group">
                                        {/* Pointers */}
                                        <div className="absolute -top-8 w-full flex justify-center h-6">
                                            {idx === p && !isFinished && (
                                                <div className="absolute top-0 flex flex-col items-center pointer-transition">
                                                    <span className="text-[10px] font-bold text-violet-600 mb-0.5">P</span>
                                                    <div className="w-0 h-0 border-l-[4px] border-l-transparent border-r-[4px] border-r-transparent border-t-[6px] border-t-violet-600"></div>
                                                </div>
                                            )}
                                            {idx === p1 && (
                                                <div className="absolute top-0 flex flex-col items-center pointer-transition" style={{transform: idx===p ? 'translateY(-18px)' : ''}}>
                                                    <span className="text-[10px] font-bold text-blue-600 mb-0.5">P1</span>
                                                    <div className="w-0 h-0 border-l-[4px] border-l-transparent border-r-[4px] border-r-transparent border-t-[6px] border-t-blue-600"></div>
                                                </div>
                                            )}
                                        </div>

                                        <div className={getCellClass1(idx)}>
                                            {num !== null ? num : ''}
                                        </div>
                                        <span className="text-[10px] text-slate-300 mt-2 font-mono">{idx}</span>
                                    </div>
                                ))}
                            </div>
                            <div className="absolute -left-4 top-1/2 -translate-y-1/2 -rotate-90 text-xs font-bold text-slate-400 origin-center">Nums1</div>
                        </div>

                        {/* Nums 2 (Source) */}
                        <div className="relative w-full overflow-x-auto flex justify-center pb-2">
                            <div className="flex gap-2">
                                {nums2.map((num, idx) => (
                                    <div key={`n2-${idx}`} className="flex flex-col items-center relative group">
                                        {/* Pointer P2 */}
                                        <div className="absolute -top-8 w-full flex justify-center h-6">
                                            {idx === p2 && (
                                                <div className="flex flex-col items-center pointer-transition">
                                                    <span className="text-[10px] font-bold text-rose-600 mb-0.5">P2</span>
                                                    <div className="w-0 h-0 border-l-[4px] border-l-transparent border-r-[4px] border-r-transparent border-t-[6px] border-t-rose-600"></div>
                                                </div>
                                            )}
                                        </div>

                                        <div className={getCellClass2(idx)}>
                                            {num}
                                        </div>
                                        <span className="text-[10px] text-slate-300 mt-2 font-mono">{idx}</span>
                                    </div>
                                ))}
                            </div>
                            <div className="absolute -left-4 top-1/2 -translate-y-1/2 -rotate-90 text-xs font-bold text-slate-400 origin-center">Nums2</div>
                        </div>

                    </div>

                    {/* Controls */}
                    <div className="border-t border-slate-100 p-4 bg-white">
                        <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
                            <div className={`flex-1 px-4 py-3 rounded-lg text-sm border-l-4 w-full sm:w-auto transition-colors ${isFinished ? 'bg-green-50 text-green-800 border-green-500' : 'bg-violet-50 text-violet-900 border-violet-500'}`}>
                                {message}
                            </div>

                            <div className="flex items-center gap-2">
                                <button onClick={() => setIsPlaying(!isPlaying)} disabled={isFinished} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-white font-medium transition ${isPlaying ? 'bg-slate-500 hover:bg-slate-600' : 'bg-violet-600 hover:bg-violet-700'} disabled:opacity-50`}>
                                    {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                                    <span className="hidden sm:inline">{isPlaying ? "暂停" : "运行"}</span>
                                </button>
                                <button onClick={stepForward} disabled={isPlaying || isFinished} className="flex items-center gap-2 px-4 py-2 bg-white border border-slate-300 text-slate-700 rounded-lg hover:bg-slate-50 font-medium transition disabled:opacity-50">
                                    <Icons.Step />
                                    <span className="hidden sm:inline">单步</span>
                                </button>
                                <button onClick={() => reset()} className="p-2 text-slate-400 hover:text-slate-600 hover:bg-slate-100 rounded-lg transition" title="重置">
                                    <Icons.Reset />
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êé•Èõ®Ê∞¥ - ÁÆóÊ≥ïÂèØËßÜÂåñ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { background-color: #f8fafc; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .bar-transition { transition: height 0.4s ease-out, background-color 0.3s; }
        .water-fill {
            background: rgba(59, 130, 246, 0.6);
            position: absolute;
            width: 100%;
            transition: height 0.4s ease-out;
            bottom: 0;
            z-index: 10;
        }
        /* Ê∞¥Ê≥¢Á∫πÊïàÊûú */
        .water-surface {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(147, 197, 253, 0.8);
            box-shadow: 0 0 4px rgba(59, 130, 246, 0.8);
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    // --- ÂõæÊ†áÁªÑ‰ª∂ ---
    const Icons = {
        Play: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
        Pause: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        Step: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>,
        Reset: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /></svg>,
        Settings: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>,
        Shuffle: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>,
        CloudRain: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path></svg>,
        Move: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="19 9 22 12 19 15"></polyline><polyline points="15 19 12 22 9 19"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></svg>,
        Layers: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>,
        Eye: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>
    };

    const App = () => {
        const [inputStr, setInputStr] = useState("0,1,0,2,1,0,1,3,2,1,2,1");
        const [heights, setHeights] = useState([0,1,0,2,1,0,1,3,2,1,2,1]);
        const [mode, setMode] = useState("twoPointer");
        const [isPlaying, setIsPlaying] = useState(false);
        const [isFinished, setIsFinished] = useState(false);
        const [message, setMessage] = useState("ÂáÜÂ§áÂ∞±Áª™");

        // ÁÆóÊ≥ïÁä∂ÊÄÅ
        const [water, setWater] = useState([]); // Array storing water amount at each index
        const [totalWater, setTotalWater] = useState(0);
        const [left, setLeft] = useState(0);
        const [right, setRight] = useState(11);
        const [lMax, setLMax] = useState(0);
        const [rMax, setRMax] = useState(0);
        const [dpPhase, setDpPhase] = useState("INIT");
        const [leftMaxArr, setLeftMaxArr] = useState([]);
        const [rightMaxArr, setRightMaxArr] = useState([]);
        const [currIdx, setCurrIdx] = useState(0);
        const [showHint, setShowHint] = useState(false); // New: Preview final water

        // Pre-calculate hint water
        const hintWater = useMemo(() => {
            if(!heights.length) return [];
            const n = heights.length;
            const l = new Array(n).fill(0);
            const r = new Array(n).fill(0);
            l[0] = heights[0];
            for(let i=1; i<n; i++) l[i] = Math.max(l[i-1], heights[i]);
            r[n-1] = heights[n-1];
            for(let i=n-2; i>=0; i--) r[i] = Math.max(r[i+1], heights[i]);

            return heights.map((h, i) => Math.max(0, Math.min(l[i], r[i]) - h));
        }, [heights]);

        const parseInput = () => {
            try {
                const arr = inputStr.split(/[,Ôºå\s]+/).filter(v => v.trim() !== "").map(Number);
                if (arr.length < 2) throw new Error("Êï∞ÁªÑÈïøÂ∫¶Ëá≥Â∞ë‰∏∫ 2");
                setHeights(arr);
                resetState(arr);
                setMessage(`Â∑≤Âä†ËΩΩ„ÄÇÂÖ± ${arr.length} ‰∏™È´òÂ∫¶„ÄÇ`);
            } catch (e) {
                setMessage("ËæìÂÖ•ÈîôËØØ: " + e.message);
            }
        };

        const resetState = (arr = heights) => {
            setIsPlaying(false);
            setIsFinished(false);
            setMessage("Áä∂ÊÄÅÂ∑≤ÈáçÁΩÆ");
            setWater(new Array(arr.length).fill(0));
            setTotalWater(0);

            // Reset Algo Vars
            setLeft(0);
            setRight(arr.length - 1);
            setLMax(0);
            setRMax(0);
            setDpPhase("INIT");
            setLeftMaxArr(new Array(arr.length).fill(0));
            setRightMaxArr(new Array(arr.length).fill(0));
            setCurrIdx(0);
        };

        const randomInput = () => {
            const len = 10 + Math.floor(Math.random() * 6);
            const arr = Array.from({length: len}, () => Math.floor(Math.random() * 5));
            if (len > 2) {
                arr[0] = Math.max(arr[0], 2);
                arr[len-1] = Math.max(arr[len-1], 2);
                arr[Math.floor(len/2)] = 0;
            }
            setInputStr(arr.join(","));
            setHeights(arr);
            resetState(arr);
            setMessage("Â∑≤ÁîüÊàêÈöèÊú∫Âú∞ÂΩ¢„ÄÇ");
        };

        useEffect(() => {
            let timer;
            if (isPlaying && !isFinished) {
                timer = setInterval(() => {
                    stepForward();
                }, mode === 'dp' && dpPhase !== 'CALC' ? 150 : 600);
            }
            return () => clearInterval(timer);
        }, [isPlaying, isFinished, mode, left, right, lMax, rMax, dpPhase, currIdx]);

        const stepForward = () => {
            if (isFinished) return;
            if (mode === 'twoPointer') stepTwoPointer();
            else stepDP();
        };

        const stepTwoPointer = () => {
            if (left > right) {
                setIsFinished(true);
                setIsPlaying(false);
                setMessage(`ËÆ°ÁÆóÁªìÊùüÔºÅÊÄªÊé•Ê∞¥Èáè: ${totalWater}`);
                return;
            }

            // Standard Two Pointer Logic adjusted for Step-by-Step
            // We process the smaller side
            const hLeft = heights[left];
            const hRight = heights[right];

            // Update Maxes first (conceptually happens as we move)
            // In this visualizer, we update maxes THEN move

            if (hLeft <= hRight) {
                // Decide based on LMax
                const newLMax = Math.max(lMax, hLeft);
                const trapped = Math.max(0, newLMax - hLeft);

                setLMax(newLMax);

                if (trapped > 0) {
                    const newWater = [...water];
                    newWater[left] = trapped;
                    setWater(newWater);
                    setTotalWater(prev => prev + trapped);
                }

                setMessage(`Â∑¶Ëæπ (${hLeft}) <= Âè≥Ëæπ (${hRight})„ÄÇÂ∑¶ÊúÄÂ§ß: ${newLMax}„ÄÇÁßØÊ∞¥: ${trapped}`);
                setLeft(left + 1);
            } else {
                const newRMax = Math.max(rMax, hRight);
                const trapped = Math.max(0, newRMax - hRight);

                setRMax(newRMax);

                if (trapped > 0) {
                    const newWater = [...water];
                    newWater[right] = trapped;
                    setWater(newWater);
                    setTotalWater(prev => prev + trapped);
                }

                setMessage(`Âè≥Ëæπ (${hRight}) < Â∑¶Ëæπ (${hLeft})„ÄÇÂè≥ÊúÄÂ§ß: ${newRMax}„ÄÇÁßØÊ∞¥: ${trapped}`);
                setRight(right - 1);
            }
        };

        const stepDP = () => {
            const n = heights.length;
            if (dpPhase === "INIT") {
                setDpPhase("LEFT");
                setCurrIdx(0);
                setMessage("DPÈò∂ÊÆµ 1: ËÆ°ÁÆóÂ∑¶‰æßÊúÄÂ§ßÈ´òÂ∫¶Êï∞ÁªÑ (LeftMax)„ÄÇ");
                return;
            }
            if (dpPhase === "LEFT") {
                if (currIdx >= n) {
                    setDpPhase("RIGHT");
                    setCurrIdx(n - 1);
                    setMessage("DPÈò∂ÊÆµ 2: ËÆ°ÁÆóÂè≥‰æßÊúÄÂ§ßÈ´òÂ∫¶Êï∞ÁªÑ (RightMax)„ÄÇ");
                    return;
                }
                const prev = currIdx === 0 ? 0 : leftMaxArr[currIdx-1];
                const val = Math.max(prev, heights[currIdx]);
                const newArr = [...leftMaxArr];
                newArr[currIdx] = val;
                setLeftMaxArr(newArr);
                setCurrIdx(currIdx + 1);
            }
            else if (dpPhase === "RIGHT") {
                if (currIdx < 0) {
                    setDpPhase("CALC");
                    setCurrIdx(0);
                    setMessage("DPÈò∂ÊÆµ 3: ËÆ°ÁÆóÊúÄÁªàÁßØÊ∞¥„ÄÇWater[i] = min(L[i], R[i]) - Height[i]");
                    return;
                }
                const prev = currIdx === n - 1 ? 0 : rightMaxArr[currIdx+1];
                const val = Math.max(prev, heights[currIdx]);
                const newArr = [...rightMaxArr];
                newArr[currIdx] = val;
                setRightMaxArr(newArr);
                setCurrIdx(currIdx - 1);
            }
            else if (dpPhase === "CALC") {
                if (currIdx >= n) {
                    setIsFinished(true);
                    setIsPlaying(false);
                    setMessage(`ËÆ°ÁÆóÁªìÊùüÔºÅÊÄªÊé•Ê∞¥Èáè: ${totalWater}`);
                    return;
                }
                const h = heights[currIdx];
                const minH = Math.min(leftMaxArr[currIdx], rightMaxArr[currIdx]);
                const trapped = Math.max(0, minH - h);

                if (trapped > 0) {
                    const newWater = [...water];
                    newWater[currIdx] = trapped;
                    setWater(newWater);
                    setTotalWater(prev => prev + trapped);
                }
                setCurrIdx(currIdx + 1);
            }
        };

        const maxH = Math.max(...heights, 1) + 2;

        return (
            <div className="max-w-4xl mx-auto p-6">
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-4 mb-6">
                    <div className="flex flex-col sm:flex-row gap-3">
                        <div className="flex-1">
                            <label className="text-xs text-slate-400 font-bold ml-1 mb-1 block">Âú∞ÂΩ¢È´òÂ∫¶</label>
                            <input type="text" value={inputStr} onChange={(e) => setInputStr(e.target.value)} className="w-full border border-slate-300 rounded-lg px-3 py-2 font-mono text-sm" />
                        </div>
                        <div className="flex items-end gap-2">
                            <button onClick={parseInput} className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm">Âä†ËΩΩ</button>
                            <button onClick={randomInput} className="px-3 py-2 bg-slate-100 text-slate-600 rounded-lg text-sm"><Icons.Shuffle /></button>
                        </div>
                    </div>
                </div>

                <div className="bg-white rounded-xl shadow-lg border border-slate-200 overflow-hidden">
                    <div className="border-b border-slate-100 bg-slate-50 p-4 flex justify-between items-center">
                        <div className="flex items-center gap-2">
                            <h1 className="text-xl font-bold text-slate-800 flex items-center gap-2"><Icons.CloudRain /> Êé•Èõ®Ê∞¥</h1>
                            <div className="flex bg-slate-200 p-1 rounded-lg ml-4">
                                <button onClick={() => { setMode('twoPointer'); resetState(); }} className={`px-2 py-1 text-xs rounded transition-all ${mode === 'twoPointer' ? 'bg-white shadow' : 'text-slate-500'}`}>ÂèåÊåáÈíà</button>
                                <button onClick={() => { setMode('dp'); resetState(); }} className={`px-2 py-1 text-xs rounded transition-all ${mode === 'dp' ? 'bg-white shadow' : 'text-slate-500'}`}>Âä®ÊÄÅËßÑÂàí</button>
                            </div>
                        </div>
                        <div className="flex items-center gap-4">
                            <label className="flex items-center gap-2 text-xs font-bold text-slate-500 cursor-pointer select-none">
                                <input type="checkbox" checked={showHint} onChange={e => setShowHint(e.target.checked)} className="rounded text-blue-500 focus:ring-blue-500" />
                                <span>üëÄ È¢ÑËßàÁªìÊûú</span>
                            </label>
                            <div className="bg-blue-50 px-3 py-1 rounded text-blue-700 font-bold text-lg">Total: {totalWater}</div>
                        </div>
                    </div>

                    <div className="p-8 bg-slate-50 min-h-[400px] flex flex-col relative justify-end">
                        {/* Chart Container - Fixed Height to prevent collapse */}
                        <div className="w-full h-[300px] flex items-end justify-center gap-1 border-b-4 border-slate-300 relative px-4">
                            {heights.map((h, i) => {
                                const active = (mode === 'twoPointer' && (i === left || i === right)) || (mode === 'dp' && i === currIdx);
                                const wVal = water[i];
                                const hintVal = hintWater[i];

                                return (
                                    <div key={i} className="flex-1 h-full flex flex-col justify-end relative group">

                                        {/* Hint Water (Ghost) */}
                                        {showHint && hintVal > 0 && (
                                            <div className="water-fill opacity-20 pointer-events-none"
                                                 style={{ height: `${(hintVal / maxH) * 100}%`, bottom: `${(h / maxH) * 100}%` }}>
                                            </div>
                                        )}

                                        {/* Actual Water */}
                                        {wVal > 0 && (
                                            <div className="water-fill"
                                                 style={{ height: `${(wVal / maxH) * 100}%`, bottom: `${(h / maxH) * 100}%` }}>
                                                <div className="water-surface"></div>
                                            </div>
                                        )}

                                        {/* Wall Bar */}
                                        <div
                                            className={`w-full rounded-t-sm z-20 bar-transition ${active ? 'bg-slate-800' : 'bg-slate-600'}`}
                                            style={{ height: `${Math.max(1, (h / maxH) * 100)}%` }} // Ensure at least 1% height for visibility
                                        >
                                            {/* Tooltip */}
                                            <div className="absolute -top-8 left-1/2 -translate-x-1/2 bg-black text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-50 pointer-events-none">
                                                H:{h}, W:{wVal}
                                            </div>
                                        </div>

                                        {/* Ground Slot Indicator (Light Gray) */}
                                        <div className="absolute bottom-0 w-full bg-slate-200/50 rounded-t-sm z-0" style={{height: '100%'}}></div>

                                        {/* Labels */}
                                        <div className="absolute -bottom-6 left-1/2 -translate-x-1/2 text-[10px] text-slate-400 font-mono">{i}</div>
                                        {active && <div className="absolute -bottom-10 left-1/2 -translate-x-1/2 text-xs font-bold text-blue-500 animate-bounce">‚¨Ü</div>}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="border-t border-slate-100 p-4 bg-white flex justify-between items-center">
                        <div className="text-sm text-slate-600 font-medium">{message}</div>
                        <div className="flex gap-2">
                            <button onClick={() => setIsPlaying(!isPlaying)} disabled={isFinished} className="flex items-center gap-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 text-sm">
                                {isPlaying ? <Icons.Pause /> : <Icons.Play />} <span>{isPlaying ? "ÊöÇÂÅú" : "ÂºÄÂßã"}</span>
                            </button>
                            <button onClick={stepForward} disabled={isPlaying || isFinished} className="flex items-center gap-1 px-4 py-2 bg-white border rounded hover:bg-slate-50 disabled:opacity-50 text-sm">
                                <Icons.Step /> <span>ÂçïÊ≠•</span>
                            </button>
                            <button onClick={() => resetState()} className="px-3 py-2 text-slate-500 hover:bg-slate-100 rounded text-sm">
                                <Icons.Reset />
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
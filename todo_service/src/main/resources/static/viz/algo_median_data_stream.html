<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据流的中位数 - 算法可视化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { background-color: #f8fafc; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .transition-all-500 { transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        .fade-in-up { animation: fadeInUp 0.5s ease-out forwards; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* 堆节点样式 */
        .heap-node {
            transition: all 0.5s ease;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- 图标组件 ---
    const Icons = {
        Play: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
        Pause: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        Step: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>,
        Reset: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /></svg>,
        Settings: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>,
        Shuffle: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>
    };

    // --- 简单的二叉堆实现 (用于后台逻辑计算) ---
    class Heap {
        constructor(compare) {
            this.data = [];
            this.compare = compare; // (a, b) => boolean (true if a should be above b)
        }
        push(val) {
            this.data.push(val);
            this.bubbleUp(this.data.length - 1);
        }
        pop() {
            if (this.data.length === 0) return null;
            const top = this.data[0];
            const bottom = this.data.pop();
            if (this.data.length > 0) {
                this.data[0] = bottom;
                this.bubbleDown(0);
            }
            return top;
        }
        peek() { return this.data[0]; }
        size() { return this.data.length; }
        bubbleUp(idx) {
            while (idx > 0) {
                let p = Math.floor((idx - 1) / 2);
                if (this.compare(this.data[idx], this.data[p])) {
                    [this.data[idx], this.data[p]] = [this.data[p], this.data[idx]];
                    idx = p;
                } else break;
            }
        }
        bubbleDown(idx) {
            while (true) {
                let swap = null;
                let left = idx * 2 + 1, right = idx * 2 + 2;
                if (left < this.data.length && this.compare(this.data[left], this.data[idx])) swap = left;
                if (right < this.data.length && this.compare(this.data[right], swap !== null ? this.data[swap] : this.data[idx])) swap = right;
                if (swap !== null) {
                    [this.data[idx], this.data[swap]] = [this.data[swap], this.data[idx]];
                    idx = swap;
                } else break;
            }
        }
    }

    const App = () => {
        // --- 状态定义 ---
        const [inputStr, setInputStr] = useState("5, 15, 1, 3, 8, 7, 9, 10");

        // 核心数据 (这里直接存储数组用于展示，逻辑在step中处理)
        const [leftHeap, setLeftHeap] = useState([]); // Max Heap (Stores smaller half)
        const [rightHeap, setRightHeap] = useState([]); // Min Heap (Stores larger half)
        const [inputValue, setInputValue] = useState(null); // 当前正在处理的数字
        const [median, setMedian] = useState(null);

        // 运行控制
        const [inputStream, setInputStream] = useState([]);
        const [streamIndex, setStreamIndex] = useState(0);
        const [phase, setPhase] = useState("idle"); // idle, adding, balancing, calculating
        const [message, setMessage] = useState("准备就绪");
        const [isPlaying, setIsPlaying] = useState(false);
        const [isFinished, setIsFinished] = useState(false);

        const timerRef = useRef(null);

        // --- 辅助函数 ---
        const parseInput = (str) => str.split(/[,，\s]+/).map(v => parseInt(v.trim())).filter(v => !isNaN(v));

        const reset = (newStream = null) => {
            setIsPlaying(false);
            setIsFinished(false);
            setLeftHeap([]);
            setRightHeap([]);
            setInputValue(null);
            setMedian(null);
            setStreamIndex(0);
            setPhase("idle");
            setMessage("状态已重置");
            if (newStream) setInputStream(newStream);
        };

        const loadInput = () => {
            const arr = parseInput(inputStr);
            if (arr.length === 0) return;
            reset(arr);
            setMessage(`已加载数据流，共 ${arr.length} 个数字`);
        };

        const randomInput = () => {
            const len = 8 + Math.floor(Math.random() * 5);
            const arr = Array.from({length: len}, () => Math.floor(Math.random() * 50) + 1);
            const str = arr.join(", ");
            setInputStr(str);
            reset(arr);
            setMessage("已生成随机数据流");
        };

        // --- 核心算法逻辑 (单步模拟) ---
        // 为了可视化的流畅性，我们手动模拟堆的操作步骤
        const stepForward = () => {
            if (streamIndex >= inputStream.length && phase === 'idle') {
                setIsFinished(true);
                setIsPlaying(false);
                setMessage("数据流处理完毕。");
                return;
            }

            // Phase 1: 引入新数字
            if (phase === 'idle') {
                const num = inputStream[streamIndex];
                setInputValue(num);
                setPhase('adding');
                setMessage(`读取新数字: ${num}`);
                return;
            }

            // Phase 2: 插入到合适的堆
            if (phase === 'adding') {
                const num = inputValue;
                let newLeft = [...leftHeap];
                let newRight = [...rightHeap];
                let msg = "";

                // 简单的逻辑：先根据大小决定去向
                // 规则：
                // 1. 如果 MaxHeap (Left) 为空，或者 num <= MaxHeap.top，放入 Left
                // 2. 否则放入 Right

                // 辅助获取堆顶
                const maxHeapTop = newLeft.length > 0 ? Math.max(...newLeft) : -Infinity;
                // 注意：为了简化可视化代码，这里用数组模拟，每次 sort 来模拟堆结构
                // 实际堆不需要每次全排，但为了展示“有序性”或者 Root 位置，这里简单处理

                if (newLeft.length === 0 || num <= maxHeapTop) {
                    newLeft.push(num);
                    newLeft.sort((a, b) => b - a); // Max Heap Descending
                    msg = `${num} <= 左侧最大值 (${maxHeapTop === -Infinity ? '空' : maxHeapTop})，加入左侧最大堆。`;
                } else {
                    newRight.push(num);
                    newRight.sort((a, b) => a - b); // Min Heap Ascending
                    msg = `${num} > 左侧最大值 (${maxHeapTop})，加入右侧最小堆。`;
                }

                setLeftHeap(newLeft);
                setRightHeap(newRight);
                setInputValue(null);
                setPhase('balancing');
                setMessage(msg);
                return;
            }

            // Phase 3: 平衡两个堆的大小
            if (phase === 'balancing') {
                let newLeft = [...leftHeap];
                let newRight = [...rightHeap];
                let unbalanced = false;
                let msg = "两个堆大小平衡，无需调整。";

                // 规则：两个堆的大小差不能超过 1
                // 或是我们约定：Left.size >= Right.size (Left 可以多 1 个)

                // 检查：如果 Left 比 Right 多 2 个以上 -> 移一个去 Right
                if (newLeft.length > newRight.length + 1) {
                    const moveVal = newLeft.shift(); // Max Heap Top is index 0 (sorted desc)
                    newRight.push(moveVal);
                    newRight.sort((a, b) => a - b);
                    msg = `左侧堆(${newLeft.length}) 比 右侧堆(${newRight.length-1}) 多太多，将堆顶 ${moveVal} 移至右侧。`;
                    unbalanced = true;
                }
                // 检查：如果 Right 比 Left 多 -> 移一个去 Left
                else if (newRight.length > newLeft.length) {
                    const moveVal = newRight.shift(); // Min Heap Top is index 0 (sorted asc)
                    newLeft.push(moveVal);
                    newLeft.sort((a, b) => b - a);
                    msg = `右侧堆(${newRight.length}) 比 左侧堆(${newLeft.length-1}) 多，将堆顶 ${moveVal} 移至左侧。`;
                    unbalanced = true;
                }

                if (unbalanced) {
                    setLeftHeap(newLeft);
                    setRightHeap(newRight);
                    // 还在 balancing 阶段，可能还需要再检查吗？
                    // 理论上一次操作即可平衡，但为了动画清晰，我们在这里停留
                    // 下一步直接进 calculating
                }

                setPhase('calculating');
                setMessage(unbalanced ? msg : "堆平衡检查完毕，计算中位数。");
                return;
            }

            // Phase 4: 计算中位数
            if (phase === 'calculating') {
                let med;
                if (leftHeap.length > rightHeap.length) {
                    med = leftHeap[0];
                    setMessage(`左侧堆元素更多，中位数为左侧堆顶: ${med}`);
                } else if (leftHeap.length < rightHeap.length) {
                    // 根据上面的平衡逻辑，其实通常是 Left >= Right，但如果用了其他策略也可能 Right > Left
                    med = rightHeap[0];
                    setMessage(`右侧堆元素更多，中位数为右侧堆顶: ${med}`);
                } else {
                    med = (leftHeap[0] + rightHeap[0]) / 2.0;
                    setMessage(`两侧堆元素相等，中位数为两堆顶平均值: (${leftHeap[0]} + ${rightHeap[0]}) / 2 = ${med}`);
                }
                setMedian(med);
                setPhase('idle');
                setStreamIndex(prev => prev + 1);
                return;
            }
        };

        // --- 自动播放 ---
        useEffect(() => {
            let timer;
            if (isPlaying && !isFinished) {
                timer = setInterval(() => {
                    stepForward();
                }, 1000);
            }
            return () => clearInterval(timer);
        }, [isPlaying, isFinished, phase, streamIndex, leftHeap, rightHeap]);

        // --- 渲染辅助 ---
        // 渲染堆可视化的 Tree View 比较复杂，这里用 "Sorted Array / Pyramid" 视图
        // 堆顶最重要，放在最上面
        const renderHeap = (data, title, colorClass) => {
            // data[0] is Top
            return (
                <div className={`flex flex-col items-center flex-1 p-4 rounded-xl border-2 ${colorClass.border} bg-white min-h-[240px] shadow-sm relative`}>
                    <div className={`absolute top-0 left-0 right-0 py-2 px-4 ${colorClass.bg} ${colorClass.text} font-bold text-center uppercase text-xs tracking-wider rounded-t-lg`}>
                        {title} (Size: {data.length})
                    </div>
                    <div className="mt-8 w-full flex flex-col items-center gap-2">
                        {data.length === 0 && <div className="text-slate-300 mt-10 italic">Empty</div>}
                        {data.map((val, idx) => (
                            <div key={idx}
                                 className={`
                                    w-16 h-10 flex items-center justify-center rounded-lg font-mono font-bold shadow-sm transition-all-500 fade-in-up
                                    ${idx === 0 ? 'scale-110 z-10 ring-4 ring-offset-2 ' + colorClass.ring : ''}
                                    ${colorClass.nodeBg} ${colorClass.nodeText}
                                 `}
                                 style={{
                                     width: `${Math.max(3, 8 - idx * 0.5)}rem`, // 简单的金字塔效果
                                     opacity: 1 - idx * 0.1
                                 }}
                            >
                                {val}
                                {idx === 0 && <span className="absolute -right-8 text-[10px] text-slate-400 font-normal">Top</span>}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        return (
            <div className="max-w-4xl mx-auto p-4 sm:p-6">
                {/* 1. 顶部配置 */}
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-4 mb-6">
                    <div className="flex items-center gap-2 mb-3 text-slate-700 font-bold">
                        <Icons.Settings />
                        <span>数据配置</span>
                    </div>
                    <div className="flex flex-col sm:flex-row gap-3">
                        <input
                            type="text"
                            value={inputStr}
                            onChange={(e) => setInputStr(e.target.value)}
                            className="flex-1 border border-slate-300 rounded-lg px-3 py-2 font-mono text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            placeholder="输入数字..."
                        />
                        <div className="flex gap-2">
                            <button onClick={loadInput} className="px-4 py-2 bg-cyan-600 text-white rounded-lg hover:bg-cyan-700 transition font-medium text-sm">
                                加载
                            </button>
                            <button onClick={randomInput} className="px-3 py-2 bg-slate-100 text-slate-600 rounded-lg hover:bg-slate-200 transition" title="随机">
                                <Icons.Shuffle />
                            </button>
                        </div>
                    </div>
                </div>

                {/* 2. 主体区 */}
                <div className="bg-white rounded-xl shadow-lg border border-slate-200 overflow-hidden">
                    {/* Header */}
                    <div className="border-b border-slate-100 bg-slate-50 p-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                        <div>
                            <h1 className="text-xl font-bold text-slate-800">数据流的中位数</h1>
                            <p className="text-xs text-slate-500 mt-1">双堆法 (MaxHeap + MinHeap) · O(log N) 插入</p>
                        </div>
                        {/* Stream Preview */}
                        <div className="flex items-center gap-2 text-sm overflow-x-auto max-w-[200px] no-scrollbar">
                            {inputStream.map((n, i) => (
                                <span key={i} className={`px-2 py-1 rounded ${i === streamIndex ? 'bg-cyan-500 text-white font-bold' : i < streamIndex ? 'text-slate-300 line-through' : 'text-slate-500 bg-slate-100'}`}>
                                    {n}
                                </span>
                            ))}
                        </div>
                    </div>

                    {/* Canvas */}
                    <div className="p-4 sm:p-8 bg-slate-50 min-h-[300px]">

                        {/* Input & Median Display */}
                        <div className="flex justify-center items-center gap-8 mb-8">
                            <div className={`flex flex-col items-center transition-all ${inputValue !== null ? 'opacity-100 transform scale-100' : 'opacity-0 transform scale-90'}`}>
                                <span className="text-xs font-bold text-slate-400 uppercase mb-1">Incoming</span>
                                <div className="w-12 h-12 rounded-full bg-slate-800 text-white flex items-center justify-center font-bold text-lg shadow-lg">
                                    {inputValue}
                                </div>
                            </div>

                            <div className="h-10 w-px bg-slate-300"></div>

                            <div className="flex flex-col items-center">
                                <span className="text-xs font-bold text-cyan-600 uppercase mb-1">Current Median</span>
                                <div className="text-3xl font-black text-cyan-600">
                                    {median !== null ? median : '--'}
                                </div>
                            </div>
                        </div>

                        {/* Heaps */}
                        <div className="flex gap-4 sm:gap-8 items-start">
                            {/* Left: Max Heap (Small Numbers) */}
                            {renderHeap(leftHeap, "Max Heap (较小半区)", {
                                border: "border-blue-200",
                                bg: "bg-blue-100",
                                text: "text-blue-700",
                                nodeBg: "bg-blue-500",
                                nodeText: "text-white",
                                ring: "ring-blue-200"
                            })}

                            {/* Right: Min Heap (Large Numbers) */}
                            {renderHeap(rightHeap, "Min Heap (较大半区)", {
                                border: "border-rose-200",
                                bg: "bg-rose-100",
                                text: "text-rose-700",
                                nodeBg: "bg-rose-500",
                                nodeText: "text-white",
                                ring: "ring-rose-200"
                            })}
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="border-t border-slate-100 p-4 bg-white">
                        <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
                            <div className="flex-1 bg-cyan-50 text-cyan-900 px-4 py-3 rounded-lg text-sm border-l-4 border-cyan-500 w-full sm:w-auto transition-colors">
                                {message}
                            </div>

                            <div className="flex items-center gap-2">
                                <button onClick={() => setIsPlaying(!isPlaying)} disabled={isFinished} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-white font-medium transition ${isPlaying ? 'bg-amber-500 hover:bg-amber-600' : 'bg-cyan-600 hover:bg-cyan-700'} disabled:opacity-50`}>
                                    {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                                    <span className="hidden sm:inline">{isPlaying ? "暂停" : "运行"}</span>
                                </button>
                                <button onClick={stepForward} disabled={isPlaying || isFinished} className="flex items-center gap-2 px-4 py-2 bg-white border border-slate-300 text-slate-700 rounded-lg hover:bg-slate-50 font-medium transition disabled:opacity-50">
                                    <Icons.Step />
                                    <span className="hidden sm:inline">单步</span>
                                </button>
                                <button onClick={() => reset(inputStream)} className="p-2 text-slate-400 hover:text-slate-600 hover:bg-slate-100 rounded-lg transition" title="重置">
                                    <Icons.Reset />
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
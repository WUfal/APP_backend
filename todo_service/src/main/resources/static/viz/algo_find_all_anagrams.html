<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊâæÂà∞Â≠óÁ¨¶‰∏≤‰∏≠ÊâÄÊúâÂ≠óÊØçÂºÇ‰ΩçËØç - ÁÆóÊ≥ïÂèØËßÜÂåñ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { background-color: #f8fafc; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .cell-transition { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .bar-transition { transition: height 0.3s ease, background-color 0.3s ease; }
        .fade-enter { animation: fadeIn 0.4s ease-out forwards; }
        .pop-in { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    // --- ÂõæÊ†áÁªÑ‰ª∂ ---
    const Icons = {
        Play: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
        Pause: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        Step: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>,
        Reset: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /></svg>,
        Settings: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>,
        Shuffle: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>,
        BarChart: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></svg>,
        Search: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>,
        Window: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
    };

    const App = () => {
        // --- Áä∂ÊÄÅÂÆö‰πâ ---
        const [sInput, setSInput] = useState("cbaebabacd");
        const [pInput, setPInput] = useState("abc");

        const [s, setS] = useState("cbaebabacd");
        const [p, setP] = useState("abc");

        // ËøêË°åÁä∂ÊÄÅ
        const [isPlaying, setIsPlaying] = useState(false);
        const [isFinished, setIsFinished] = useState(false);
        const [message, setMessage] = useState("ÂáÜÂ§áÂ∞±Áª™„ÄÇÂØªÊâæ P ÁöÑÊâÄÊúâÂºÇ‰ΩçËØç„ÄÇ");

        // ÁÆóÊ≥ïÁä∂ÊÄÅ
        const [windowLeft, setWindowLeft] = useState(0);
        const [windowRight, setWindowRight] = useState(-1); // Points to last added element
        const [pCount, setPCount] = useState(new Array(26).fill(0));
        const [windowCount, setWindowCount] = useState(new Array(26).fill(0));
        const [results, setResults] = useState([]);

        // Âä®ÁîªÈò∂ÊÆµ: INIT -> ADD -> REMOVE -> CHECK -> ADD ...
        const [phase, setPhase] = useState("INIT");

        // --- ËæÖÂä©ÂáΩÊï∞ ---
        const getCharIdx = (char) => char.charCodeAt(0) - 'a'.charCodeAt(0);

        const parseInput = () => {
            const sStr = sInput.trim().toLowerCase().replace(/[^a-z]/g, '');
            const pStr = pInput.trim().toLowerCase().replace(/[^a-z]/g, '');

            if (!sStr || !pStr) {
                setMessage("ËæìÂÖ•Êó†ÊïàÔºåËØ∑Á°Æ‰øùÂè™ÂåÖÂê´Â≠óÊØç a-z„ÄÇ");
                return;
            }
            if (pStr.length > sStr.length) {
                setMessage("P ÁöÑÈïøÂ∫¶‰∏çËÉΩÂ§ß‰∫é S„ÄÇ");
                return;
            }

            setS(sStr);
            setP(pStr);
            resetState(sStr, pStr);
            setMessage(`Â∑≤Âä†ËΩΩ„ÄÇSÈïøÂ∫¶: ${sStr.length}, PÈïøÂ∫¶: ${pStr.length}`);
        };

        const resetState = (strS = s, strP = p) => {
            setIsPlaying(false);
            setIsFinished(false);
            setMessage("Áä∂ÊÄÅÂ∑≤ÈáçÁΩÆ");

            setWindowLeft(0);
            setWindowRight(-1);

            // Initialize P Count
            const pc = new Array(26).fill(0);
            for (let char of strP) pc[getCharIdx(char)]++;
            setPCount(pc);

            setWindowCount(new Array(26).fill(0));
            setResults([]);
            setPhase("INIT");
        };

        const randomInput = () => {
            const chars = "abcde";
            const lenS = 12;
            const lenP = 3;
            let newS = "";
            let newP = "";
            for(let i=0; i<lenS; i++) newS += chars[Math.floor(Math.random() * chars.length)];
            // Ensure at least one anagram exists for fun
            const subStart = Math.floor(Math.random() * (lenS - lenP));
            const sub = newS.substring(subStart, subStart + lenP);
            newP = sub.split('').sort(() => 0.5 - Math.random()).join('');

            setSInput(newS);
            setPInput(newP);
            setS(newS);
            setP(newP);
            resetState(newS, newP);
            setMessage(`Â∑≤ÁîüÊàêÈöèÊú∫Êï∞ÊçÆ„ÄÇP ÊòØ "${newP}"`);
        };

        // --- Ëá™Âä®Êí≠Êîæ ---
        useEffect(() => {
            let timer;
            if (isPlaying && !isFinished) {
                timer = setInterval(() => {
                    stepForward();
                }, 800);
            }
            return () => clearInterval(timer);
        }, [isPlaying, isFinished, phase, windowRight, windowLeft, windowCount]);

        const stepForward = () => {
            if (isFinished) return;

            // Logic Flow:
            // INIT -> (Start Loop) -> ADD -> REMOVE (if needed) -> CHECK -> (Next Loop) ADD

            if (phase === "INIT") {
                setPhase("ADD");
                // Actually start pointing to 0
                setWindowRight(0); // Prepare to add index 0
                // Don't add yet, next step will add
                // To make logic cleaner: current state is 'Ready to Add s[windowRight]'?
                // Let's say windowRight is the index we are ABOUT to process?
                // Current logic: windowRight is last PROCESSED index.
                // So initial state is -1.
                // ADD phase: increment right, add char.
                setMessage("ÂºÄÂßãÊªëÂä®Á™óÂè£...");
                return;
            }

            if (phase === "ADD") {
                const nextRight = windowRight + 1;
                if (nextRight >= s.length) {
                    setIsFinished(true);
                    setIsPlaying(false);
                    setMessage("ÈÅçÂéÜÁªìÊùüÔºÅ");
                    return;
                }

                // Add char
                const char = s[nextRight];
                const idx = getCharIdx(char);
                const newCount = [...windowCount];
                newCount[idx]++;

                setWindowCount(newCount);
                setWindowRight(nextRight);

                let msg = `Á™óÂè£Âè≥Áßª„ÄÇÂä†ÂÖ•Â≠óÁ¨¶ '${char}'„ÄÇ`;

                // Decide next phase
                // If window size > p.length, we need to shrink FIRST?
                // Standard logic: Add, then if size > k, remove.
                // Current size after add is (nextRight - windowLeft + 1)
                if ((nextRight - windowLeft + 1) > p.length) {
                    setPhase("REMOVE");
                    setMessage(msg + " Á™óÂè£ËøáÂ§ßÔºåÂáÜÂ§áÊî∂Áº©„ÄÇ");
                } else {
                    // If size == p.length, check. If <, continue adding.
                    if ((nextRight - windowLeft + 1) === p.length) {
                        setPhase("CHECK");
                        setMessage(msg + " Á™óÂè£Â§ßÂ∞èÊª°Ë∂≥ÔºåÂáÜÂ§áÊ£ÄÊü•„ÄÇ");
                    } else {
                        // Continue adding
                        setPhase("ADD"); // Stay in ADD next tick, will increment right
                    }
                }
            }
            else if (phase === "REMOVE") {
                // Remove s[windowLeft]
                const char = s[windowLeft];
                const idx = getCharIdx(char);
                const newCount = [...windowCount];
                newCount[idx]--;

                setWindowCount(newCount);
                setWindowLeft(windowLeft + 1);

                setPhase("CHECK");
                setMessage(`Á™óÂè£Â∑¶Áßª„ÄÇÁßªÈô§Â≠óÁ¨¶ '${char}'„ÄÇÁé∞Á™óÂè£Â§ßÂ∞è‰∏∫ ${p.length}„ÄÇ`);
            }
            else if (phase === "CHECK") {
                // Compare counts
                const isMatch = pCount.every((val, i) => val === windowCount[i]);

                if (isMatch) {
                    setResults(prev => [...prev, windowLeft]);
                    setMessage(`üéâ ËÆ°Êï∞Âô®ÂåπÈÖçÔºÅÊâæÂà∞ÂºÇ‰ΩçËØçÔºåËµ∑ÂßãÁ¥¢Âºï ${windowLeft}„ÄÇ`);
                } else {
                    setMessage("ËÆ°Êï∞Âô®‰∏çÂåπÈÖç„ÄÇÁªßÁª≠ÊªëÂä®„ÄÇ");
                }

                // Go back to ADD
                setPhase("ADD");
            }
        };

        // --- Ê∏≤ÊüìËæÖÂä© ---
        const getCharStyle = (index) => {
            let base = "w-10 h-10 flex items-center justify-center border rounded font-mono font-bold relative cell-transition ";

            // Determine if inside window
            const inWindow = index >= windowLeft && index <= windowRight;

            if (inWindow) {
                base += "bg-blue-100 border-blue-500 text-blue-800 scale-105 shadow-sm z-10 ";
            } else {
                base += "bg-white border-slate-200 text-slate-400 ";
            }

            // Highlight just added or removed
            if (phase === "ADD" && index === windowRight) { // Just added
                base += "ring-2 ring-blue-300 ";
            }

            // Result highlight
            if (results.includes(index)) {
                base += "bg-green-100 border-green-500 text-green-700 ";
                // If it's start of a found word, maybe mark it
            }

            return base;
        };

        const getBarStyle = (charIdx, isP) => {
            const count = isP ? pCount[charIdx] : windowCount[charIdx];
            const max = Math.max(Math.max(...pCount), Math.max(...windowCount), 1);
            const height = Math.max((count / max) * 100, 5); // min 5%

            let color = "bg-slate-300";
            if (isP) {
                color = "bg-purple-400";
            } else {
                // Window bar
                if (count === 0) color = "bg-slate-200";
                else if (count < pCount[charIdx]) color = "bg-blue-400"; // Less than required
                else if (count === pCount[charIdx]) color = "bg-green-500"; // Exact match
                else color = "bg-red-400"; // Too many
            }

            return { height: `${height}%`, className: `w-full rounded-t ${color} bar-transition relative group` };
        };

        return (
            <div className="max-w-5xl mx-auto p-6">
                {/* 1. ÈÖçÁΩÆÂå∫ */}
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-4 mb-6">
                    <div className="flex items-center gap-2 mb-3 text-slate-700 font-bold">
                        <Icons.Settings />
                        <span>Êï∞ÊçÆÈÖçÁΩÆ</span>
                    </div>
                    <div className="flex flex-col sm:flex-row gap-3">
                        <div className="flex-1">
                            <label className="text-xs text-slate-400 font-bold ml-1 mb-1 block">Ê∫êÂ≠óÁ¨¶‰∏≤ (S)</label>
                            <input
                                type="text"
                                value={sInput}
                                onChange={(e) => setSInput(e.target.value)}
                                className="w-full border border-slate-300 rounded-lg px-3 py-2 font-mono text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                        </div>
                        <div className="w-32">
                            <label className="text-xs text-slate-400 font-bold ml-1 mb-1 block">Ê®°Âºè‰∏≤ (P)</label>
                            <input
                                type="text"
                                value={pInput}
                                onChange={(e) => setPInput(e.target.value)}
                                className="w-full border border-slate-300 rounded-lg px-3 py-2 font-mono text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                        </div>
                        <div className="flex items-end gap-2">
                            <button onClick={parseInput} className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-medium text-sm h-[42px]">
                                Âä†ËΩΩ
                            </button>
                            <button onClick={randomInput} className="px-3 py-2 bg-slate-100 text-slate-600 rounded-lg hover:bg-slate-200 transition h-[42px]" title="ÈöèÊú∫">
                                <Icons.Shuffle />
                            </button>
                        </div>
                    </div>
                </div>

                {/* 2. ‰∏ªÂå∫Âüü */}
                <div className="bg-white rounded-xl shadow-lg border border-slate-200 overflow-hidden">
                    {/* Header */}
                    <div className="border-b border-slate-100 bg-slate-50 p-4 flex justify-between items-center">
                        <div>
                            <h1 className="text-xl font-bold text-slate-800 flex items-center gap-2">
                                <Icons.Search /> ÊâæÂà∞Â≠óÁ¨¶‰∏≤‰∏≠ÊâÄÊúâÂ≠óÊØçÂºÇ‰ΩçËØç
                            </h1>
                            <p className="text-xs text-slate-500 mt-1">ÊªëÂä®Á™óÂè£ + ÂìàÂ∏åË°® (ËÆ°Êï∞Âô®) ‰ºòÂåñ„ÄÇ</p>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="text-xs font-bold text-slate-400 uppercase tracking-widest">Results:</span>
                            <div className="flex gap-1">
                                {results.length === 0 ? <span className="text-sm text-slate-300 italic">None</span> :
                                    results.map((idx, i) => (
                                        <span key={i} className="px-2 py-0.5 bg-green-100 text-green-700 rounded text-xs font-bold font-mono pop-in">{idx}</span>
                                    ))
                                }
                            </div>
                        </div>
                    </div>

                    {/* Visualization Canvas */}
                    <div className="p-8 bg-slate-50 min-h-[300px] flex flex-col gap-8">

                        {/* String Display */}
                        <div className="flex flex-col items-center">
                            <div className="text-xs font-bold text-slate-400 mb-2 tracking-widest w-full max-w-3xl">SOURCE STRING (S)</div>
                            <div className="flex flex-wrap gap-1 max-w-3xl">
                                {s.split('').map((char, idx) => (
                                    <div key={idx} className="flex flex-col items-center">
                                        <div className={getCharStyle(idx)}>
                                            {char}
                                            {/* Start/End Markers */}
                                            {idx === windowLeft && <div className="absolute -top-2 left-0 w-2 h-2 bg-blue-500 rounded-full"></div>}
                                            {idx === windowRight && <div className="absolute -top-2 right-0 w-2 h-2 bg-blue-500 rounded-full"></div>}
                                        </div>
                                        <span className="text-[10px] text-slate-300 font-mono mt-1">{idx}</span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Frequency Charts */}
                        <div className="flex flex-col md:flex-row gap-8 justify-center items-end h-48">

                            {/* P Count (Target) */}
                            <div className="flex flex-col items-center w-full md:w-auto">
                                <div className="text-xs font-bold text-purple-500 mb-2 flex items-center gap-1">
                                    <Icons.BarChart /> TARGET (P)
                                </div>
                                <div className="flex items-end gap-1 h-32 p-2 bg-white rounded-lg border border-slate-200 shadow-sm">
                                    {/* Only show letters present in P or S to save space? No, showing a-z is standard but wide.
                                            Let's show only a-z. */}
                                    {Array.from({length: 26}).map((_, i) => {
                                        const char = String.fromCharCode(97 + i);
                                        // Optimization: only render bars if count > 0 in either P or Window to keep it clean?
                                        // Or render all small.
                                        // Let's render all but very thin.
                                        const style = getBarStyle(i, true);
                                        return (
                                            <div key={i} className="flex flex-col items-center w-3 sm:w-4 group">
                                                <div className="h-24 w-full flex items-end bg-slate-50 rounded-t relative">
                                                    <div style={style} className={style.className}></div>
                                                    {/* Tooltip */}
                                                    <div className="absolute bottom-full mb-1 left-1/2 -translate-x-1/2 bg-black text-white text-[10px] px-1 rounded opacity-0 group-hover:opacity-100 pointer-events-none z-20">
                                                        {pCount[i]}
                                                    </div>
                                                </div>
                                                <span className="text-[8px] text-slate-400 mt-1">{char}</span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                            {/* Divider */}
                            <div className="text-2xl text-slate-300 font-bold pb-10">VS</div>

                            {/* Window Count (Current) */}
                            <div className="flex flex-col items-center w-full md:w-auto">
                                <div className="text-xs font-bold text-blue-500 mb-2 flex items-center gap-1">
                                    <Icons.Window /> WINDOW
                                </div>
                                <div className="flex items-end gap-1 h-32 p-2 bg-white rounded-lg border border-slate-200 shadow-sm">
                                    {Array.from({length: 26}).map((_, i) => {
                                        const char = String.fromCharCode(97 + i);
                                        const style = getBarStyle(i, false);
                                        return (
                                            <div key={i} className="flex flex-col items-center w-3 sm:w-4 group">
                                                <div className="h-24 w-full flex items-end bg-slate-50 rounded-t relative">
                                                    <div style={style} className={style.className}></div>
                                                    {/* Tooltip */}
                                                    <div className="absolute bottom-full mb-1 left-1/2 -translate-x-1/2 bg-black text-white text-[10px] px-1 rounded opacity-0 group-hover:opacity-100 pointer-events-none z-20">
                                                        {windowCount[i]}
                                                    </div>
                                                </div>
                                                <span className="text-[8px] text-slate-400 mt-1">{char}</span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                        </div>

                    </div>

                    {/* Controls */}
                    <div className="border-t border-slate-100 p-4 bg-white">
                        <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
                            <div className="flex-1 bg-blue-50 text-blue-800 px-4 py-3 rounded-lg text-sm border-l-4 border-blue-500 w-full sm:w-auto shadow-sm transition-all">
                                {message}
                            </div>
                            <div className="flex items-center gap-2">
                                <button onClick={() => setIsPlaying(!isPlaying)} disabled={isFinished} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-white font-medium transition ${isPlaying ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-600 hover:bg-blue-700'} disabled:opacity-50`}>
                                    {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                                    <span className="hidden sm:inline">{isPlaying ? "ÊöÇÂÅú" : "Ëá™Âä®"}</span>
                                </button>
                                <button onClick={stepForward} disabled={isPlaying || isFinished} className="flex items-center gap-2 px-4 py-2 bg-white border border-slate-300 text-slate-700 rounded-lg hover:bg-slate-50 font-medium transition disabled:opacity-50">
                                    <Icons.Step />
                                    <span className="hidden sm:inline">ÂçïÊ≠•</span>
                                </button>
                                <button onClick={() => resetState()} className="p-2 text-slate-400 hover:text-slate-600 hover:bg-slate-100 rounded-lg transition">
                                    <Icons.Reset />
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
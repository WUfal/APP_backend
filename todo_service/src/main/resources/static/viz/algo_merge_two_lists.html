<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>算法可视化：合并两个有序链表</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
        .smooth-transition {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 节点进入动画 */
        @keyframes popIn {
            0% { transform: scale(0.5) translateY(20px); opacity: 0; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        .node-enter {
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        /* 箭头闪烁动画 */
        @keyframes arrowPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; transform: translateX(2px); }
        }
        .arrow-active {
            animation: arrowPulse 1.5s infinite;
        }

        /* 滚动条美化 */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #ede9fe; }
        ::-webkit-scrollbar-thumb { background: #8b5cf6; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #7c3aed; }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- 图标组件 ---
    const Icons = {
        Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
        Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        Step: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>,
        Refresh: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>,
        Random: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>,
        ArrowRight: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" className="text-slate-300"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
    };

    // --- 辅助函数：解析数组 ---
    const parseArray = (str) => {
        return str.split(/[,，\s]+/)
            .map(num => parseInt(num.trim()))
            .filter(n => !isNaN(n));
    };

    // --- 链表节点组件 ---
    const ListNode = ({ val, isActive, isProcessed, isResult, label }) => {
        let bgClass = "bg-white border-slate-300 text-slate-700";
        if (isActive) bgClass = "bg-violet-100 border-violet-500 text-violet-700 scale-110 shadow-md ring-2 ring-violet-200";
        if (isProcessed) bgClass = "bg-slate-100 border-slate-200 text-slate-300 opacity-50";
        if (isResult) bgClass = "bg-green-100 border-green-500 text-green-700 node-enter shadow-sm";

        return (
            <div className="flex items-center">
                <div className={`relative w-12 h-12 sm:w-14 sm:h-14 rounded-full border-2 flex items-center justify-center font-bold text-lg smooth-transition ${bgClass}`}>
                    {val}
                    {label && (
                        <span className="absolute -top-6 text-xs font-bold text-violet-600 whitespace-nowrap animate-bounce">
                                {label}
                            </span>
                    )}
                </div>
                {/* 连接箭头 (除了最后一个) */}
                <div className="mx-1 sm:mx-2">
                    <Icons.ArrowRight />
                </div>
            </div>
        );
    };

    // --- 结果链表 Null 节点 ---
    const NullNode = () => (
        <div className="flex items-center">
            <div className="w-10 h-10 sm:w-12 sm:h-12 rounded-md border-2 border-dashed border-slate-300 flex items-center justify-center text-xs font-mono text-slate-400 bg-slate-50">
                NULL
            </div>
        </div>
    );

    // --- 主应用组件 ---
    function App() {
        // --- Configuration State ---
        const [inputA, setInputA] = useState("1, 2, 4");
        const [inputB, setInputB] = useState("1, 3, 4");

        // --- Runtime State ---
        const [listA, setListA] = useState([1, 2, 4]);
        const [listB, setListB] = useState([1, 3, 4]);

        // 指针位置 (Index)
        const [ptrA, setPtrA] = useState(0);
        const [ptrB, setPtrB] = useState(0);

        // 结果链表
        const [result, setResult] = useState([]);

        const [isPlaying, setIsPlaying] = useState(false);
        const [isCompleted, setIsCompleted] = useState(false);
        const [message, setMessage] = useState("准备就绪。请输入有序链表数据。");
        const [statusColor, setStatusColor] = useState("text-slate-600");

        const timerRef = useRef(null);
        const resultEndRef = useRef(null);

        // --- Initialization ---

        const initAlgorithm = (newA = null, newB = null) => {
            const a = newA !== null ? newA : listA;
            const b = newB !== null ? newB : listB;

            setListA(a);
            setListB(b);
            setPtrA(0);
            setPtrB(0);
            setResult([]);
            setIsCompleted(false);
            setIsPlaying(false);
            setMessage("状态已重置。");
            setStatusColor("text-slate-600");
            if (timerRef.current) clearInterval(timerRef.current);
        };

        const handleApply = () => {
            const a = parseArray(inputA).sort((x, y) => x - y);
            const b = parseArray(inputB).sort((x, y) => x - y);
            setInputA(a.join(", "));
            setInputB(b.join(", "));
            initAlgorithm(a, b);
            setMessage("数据已应用并自动排序。");
        };

        const handleRandom = () => {
            const genSorted = () => {
                const len = 4 + Math.floor(Math.random() * 4);
                const arr = Array.from({length: len}, () => Math.floor(Math.random() * 20));
                return arr.sort((x, y) => x - y);
            };
            const a = genSorted();
            const b = genSorted();

            setInputA(a.join(", "));
            setInputB(b.join(", "));
            initAlgorithm(a, b);
            setMessage("随机有序链表已生成。");
        };

        // --- Algorithm Logic (Single Step) ---

        const step = () => {
            if (isCompleted) return;

            // Case 1: Both lists have nodes left
            if (ptrA < listA.length && ptrB < listB.length) {
                const valA = listA[ptrA];
                const valB = listB[ptrB];

                if (valA <= valB) {
                    // Pick A
                    setResult(prev => [...prev, valA]);
                    setPtrA(prev => prev + 1);
                    setMessage(`比较 ${valA} <= ${valB}：取链表 A 的节点 ${valA}。`);
                    setStatusColor("text-violet-600");
                } else {
                    // Pick B
                    setResult(prev => [...prev, valB]);
                    setPtrB(prev => prev + 1);
                    setMessage(`比较 ${valA} > ${valB}：取链表 B 的节点 ${valB}。`);
                    setStatusColor("text-pink-600");
                }
            }
            // Case 2: Only A left
            else if (ptrA < listA.length) {
                const valA = listA[ptrA];
                setResult(prev => [...prev, valA]);
                setPtrA(prev => prev + 1);
                setMessage(`链表 B 已空，接入链表 A 的剩余节点 ${valA}。`);
                setStatusColor("text-slate-600");
            }
            // Case 3: Only B left
            else if (ptrB < listB.length) {
                const valB = listB[ptrB];
                setResult(prev => [...prev, valB]);
                setPtrB(prev => prev + 1);
                setMessage(`链表 A 已空，接入链表 B 的剩余节点 ${valB}。`);
                setStatusColor("text-slate-600");
            }
            // Case 4: Finished
            else {
                setIsCompleted(true);
                setIsPlaying(false);
                setMessage("合并完成！");
                setStatusColor("text-green-600");
                return;
            }
        };

        // --- Auto Play & Scroll ---
        useEffect(() => {
            if (isPlaying) {
                timerRef.current = setInterval(step, 1000);
            }
            return () => clearInterval(timerRef.current);
        }, [isPlaying, ptrA, ptrB, listA, listB, isCompleted]);

        useEffect(() => {
            if(resultEndRef.current) {
                resultEndRef.current.scrollIntoView({ behavior: 'smooth', inline: 'end' });
            }
        }, [result]);

        return (
            <div className="min-h-screen flex flex-col items-center py-8 px-4 sm:px-6">

                {/* 1. Header */}
                <header className="mb-8 text-center space-y-2">
                    <h1 className="text-3xl font-extrabold text-slate-800 tracking-tight">
                        算法可视化：<span className="text-violet-600">合并两个有序链表</span>
                    </h1>
                    <p className="text-slate-500 text-sm">
                        双指针法 / 递归 · LeetCode 21
                    </p>
                </header>

                {/* 2. Configuration Card */}
                <div className="w-full max-w-4xl bg-white rounded-xl shadow-lg border border-violet-100 p-6 mb-8">
                    <div className="grid grid-cols-1 md:grid-cols-12 gap-4 items-end">
                        <div className="md:col-span-5 space-y-1">
                            <label className="text-xs font-semibold text-slate-500 uppercase flex items-center">
                                <span className="w-2 h-2 rounded-full bg-violet-500 mr-2"></span>
                                链表 A (有序)
                            </label>
                            <input
                                type="text"
                                value={inputA}
                                onChange={(e) => setInputA(e.target.value)}
                                className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-violet-500 focus:border-violet-500 outline-none text-slate-700 text-sm font-mono"
                                placeholder="1, 2, 4"
                            />
                        </div>
                        <div className="md:col-span-5 space-y-1">
                            <label className="text-xs font-semibold text-slate-500 uppercase flex items-center">
                                <span className="w-2 h-2 rounded-full bg-pink-500 mr-2"></span>
                                链表 B (有序)
                            </label>
                            <input
                                type="text"
                                value={inputB}
                                onChange={(e) => setInputB(e.target.value)}
                                className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-pink-500 outline-none text-slate-700 text-sm font-mono"
                                placeholder="1, 3, 4"
                            />
                        </div>
                        <div className="md:col-span-2 flex space-x-2">
                            <button onClick={handleApply} className="flex-1 bg-violet-600 hover:bg-violet-700 text-white px-3 py-2 rounded-lg transition-colors text-sm font-medium">应用</button>
                            <button onClick={handleRandom} className="flex-1 bg-white border border-slate-300 hover:bg-violet-50 text-slate-700 px-3 py-2 rounded-lg transition-colors text-sm font-medium">随机</button>
                        </div>
                    </div>
                </div>

                {/* 3. Visualization Area */}
                <div className="w-full max-w-4xl mb-8 space-y-6">

                    {/* 链表 A */}
                    <div className="bg-white rounded-xl shadow-sm border border-violet-100 p-4 min-h-[100px] flex items-center relative overflow-hidden">
                        <div className="absolute left-0 top-0 bottom-0 w-1 bg-violet-500"></div>
                        <span className="absolute top-2 left-3 text-xs font-bold text-violet-400">List A</span>
                        <div className="flex items-center overflow-x-auto p-4 w-full no-scrollbar">
                            {listA.map((val, idx) => (
                                <ListNode
                                    key={`A-${idx}`}
                                    val={val}
                                    isActive={!isCompleted && idx === ptrA}
                                    isProcessed={idx < ptrA}
                                    label={!isCompleted && idx === ptrA ? "Ptr A" : null}
                                />
                            ))}
                            <NullNode />
                        </div>
                    </div>

                    {/* 链表 B */}
                    <div className="bg-white rounded-xl shadow-sm border border-pink-100 p-4 min-h-[100px] flex items-center relative overflow-hidden">
                        <div className="absolute left-0 top-0 bottom-0 w-1 bg-pink-500"></div>
                        <span className="absolute top-2 left-3 text-xs font-bold text-pink-400">List B</span>
                        <div className="flex items-center overflow-x-auto p-4 w-full no-scrollbar">
                            {listB.map((val, idx) => (
                                <ListNode
                                    key={`B-${idx}`}
                                    val={val}
                                    isActive={!isCompleted && idx === ptrB}
                                    isProcessed={idx < ptrB}
                                    label={!isCompleted && idx === ptrB ? "Ptr B" : null}
                                />
                            ))}
                            <NullNode />
                        </div>
                    </div>

                    {/* 结果链表 */}
                    <div className="bg-slate-50 rounded-xl border-2 border-dashed border-slate-300 p-4 min-h-[120px] flex flex-col justify-center relative">
                        <span className="absolute top-2 left-3 text-xs font-bold text-slate-400">Merged Result</span>

                        {result.length === 0 ? (
                            <div className="text-center text-slate-400 italic">等待开始合并...</div>
                        ) : (
                            <div className="flex items-center overflow-x-auto p-4 w-full">
                                {result.map((val, idx) => (
                                    <ListNode key={`R-${idx}`} val={val} isResult={true} />
                                ))}
                                {/* 只有当完全结束时才显示 NULL */}
                                <div ref={resultEndRef}>
                                    {isCompleted && <NullNode />}
                                </div>
                            </div>
                        )}
                    </div>
                </div>

                {/* 4. Control Bar */}
                <div className="w-full max-w-2xl bg-white rounded-xl shadow-lg border border-slate-100 overflow-hidden">

                    <div className="flex items-center justify-between p-4 bg-slate-50 border-b border-slate-100">
                        <div className="flex space-x-2">
                            {!isPlaying ? (
                                <button
                                    onClick={() => setIsPlaying(true)}
                                    disabled={isCompleted}
                                    className="flex items-center space-x-1 bg-violet-600 hover:bg-violet-700 disabled:bg-violet-300 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                                >
                                    <Icons.Play /> <span>运行</span>
                                </button>
                            ) : (
                                <button
                                    onClick={() => setIsPlaying(false)}
                                    className="flex items-center space-x-1 bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                                >
                                    <Icons.Pause /> <span>暂停</span>
                                </button>
                            )}

                            <button
                                onClick={step}
                                disabled={isPlaying || isCompleted}
                                className="flex items-center space-x-1 bg-white border border-slate-300 hover:bg-slate-50 disabled:opacity-50 text-slate-700 px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                            >
                                <Icons.Step /> <span>单步</span>
                            </button>
                        </div>

                        <button
                            onClick={() => initAlgorithm()}
                            className="flex items-center space-x-1 text-slate-500 hover:text-slate-800 transition-colors text-sm"
                        >
                            <Icons.Refresh /> <span>重置</span>
                        </button>
                    </div>

                    <div className="p-6 bg-white min-h-[100px] flex items-center justify-center text-center">
                        <p className={`text-lg font-medium transition-colors duration-300 ${statusColor}`}>
                            {message}
                        </p>
                    </div>

                    {isPlaying && (
                        <div className="h-1 w-full bg-slate-100 overflow-hidden">
                            <div className="h-full bg-violet-500 animate-progress origin-left"></div>
                        </div>
                    )}
                </div>

                <div className="mt-8 text-slate-400 text-xs text-center">
                    <p>Linked List Merge Visualization • React + Tailwind</p>
                </div>

            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

<style>
    @keyframes progress {
        0% { width: 0%; }
        100% { width: 100%; }
    }
    .animate-progress {
        animation: progress 1s linear infinite;
    }
</style>
</body>
</html>